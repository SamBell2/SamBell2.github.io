{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sam Bell's Portfolio of Projects About Me I am a 15 year old electronics and programming enthusiast. I love computer science and everything related to digital making, and have since I learnt the basics of Python when I was 8. Since then, it has become my main hobby and the direction I want my career to go in. In 2020, I got my first Raspberry Pi and learnt about electronics. Recently I realised that digital making and robotics combine both of my main interests, and those are what I'm focusing on now. I have made loads (82 that I still have records of!) of projects of varying degrees of difficulty. This portfolio contains the ones that I am most proud of. My Favourite Projects Project Description Link Chess Bot I created a fully-functional lookahead evaluation chess bot View Project CPU A simple 8-bit CPU that I am currently making View Project QR Code Generator I made a v5 QR code generator in python View Project WER 2025 An international robotics competition where I came 1st in the UK in my age category More information My Skills Technical Skills Programming : I know how to program in many languages (e.g. C, HTML/CSS, and Go, to name a few), but my strongest are Python and Java. Electronics : Soldering, PCB Design (KiCad), and simply being able to work out how stuff should work. Tools : Git, Raspberry Pi, CAD (Autodesk Inventor & OpenSCAD) Systems : I understand how systems like Linux work due to me constantly changing, fixing and improving them on my own computer. Soft Skills Problem Solving - I have come across many challenges over my 5 years of making, and seeing as my family and friends aren't interested in coding or making, I have to solve everything myself using the internet, magazines and books. This has made me pretty good at problem solving. Curiosity - I have always wanted to know how things work, and I usually find this out by making it (e.g. my QR code generator ) Resilience - I just refuse to give up, even if a problem takes me years to solve! I started many of my projects (such as the Light Fantastic ) when I was younger and didn't have enough knowledge, skills or experience, but I kept coming back to them until I managed to finish them. Recent Achievements British champion in an international robotics competition ( WER 2025 ) Finalist in Cyber Switchup 2023 (I missed this year's deadline) Predicted Grade 9 in GCSE Computer Science Get in Touch Email: samgbell2011@icloud.com Phone: 07468 779147 Portfolio: https://sambell2.github.io View My Full Portfolio \u279c","title":"Home"},{"location":"#sam-bells-portfolio-of-projects","text":"","title":"Sam Bell's Portfolio of Projects"},{"location":"#about-me","text":"I am a 15 year old electronics and programming enthusiast. I love computer science and everything related to digital making, and have since I learnt the basics of Python when I was 8. Since then, it has become my main hobby and the direction I want my career to go in. In 2020, I got my first Raspberry Pi and learnt about electronics. Recently I realised that digital making and robotics combine both of my main interests, and those are what I'm focusing on now. I have made loads (82 that I still have records of!) of projects of varying degrees of difficulty. This portfolio contains the ones that I am most proud of.","title":"About Me"},{"location":"#my-favourite-projects","text":"Project Description Link Chess Bot I created a fully-functional lookahead evaluation chess bot View Project CPU A simple 8-bit CPU that I am currently making View Project QR Code Generator I made a v5 QR code generator in python View Project WER 2025 An international robotics competition where I came 1st in the UK in my age category More information","title":"My Favourite Projects"},{"location":"#my-skills","text":"","title":"My Skills"},{"location":"#technical-skills","text":"Programming : I know how to program in many languages (e.g. C, HTML/CSS, and Go, to name a few), but my strongest are Python and Java. Electronics : Soldering, PCB Design (KiCad), and simply being able to work out how stuff should work. Tools : Git, Raspberry Pi, CAD (Autodesk Inventor & OpenSCAD) Systems : I understand how systems like Linux work due to me constantly changing, fixing and improving them on my own computer.","title":"Technical Skills"},{"location":"#soft-skills","text":"Problem Solving - I have come across many challenges over my 5 years of making, and seeing as my family and friends aren't interested in coding or making, I have to solve everything myself using the internet, magazines and books. This has made me pretty good at problem solving. Curiosity - I have always wanted to know how things work, and I usually find this out by making it (e.g. my QR code generator ) Resilience - I just refuse to give up, even if a problem takes me years to solve! I started many of my projects (such as the Light Fantastic ) when I was younger and didn't have enough knowledge, skills or experience, but I kept coming back to them until I managed to finish them.","title":"Soft Skills"},{"location":"#recent-achievements","text":"British champion in an international robotics competition ( WER 2025 ) Finalist in Cyber Switchup 2023 (I missed this year's deadline) Predicted Grade 9 in GCSE Computer Science","title":"Recent Achievements"},{"location":"#get-in-touch","text":"Email: samgbell2011@icloud.com Phone: 07468 779147 Portfolio: https://sambell2.github.io","title":"Get in Touch"},{"location":"#view-my-full-portfolio","text":"","title":"View My Full Portfolio \u279c"},{"location":"gallery/","text":"My Projects Chess Bot (2025 - Aged 14) CPU (2025 - Aged 14) WER 2025 (2025 - Aged 14) Light Fantastic (2023-2025 - Aged 12-14) QR Code Generator (2024 - Aged 13) Laptop (2023-2025 - Aged 12-14) Scripted Journeys (2024-2025 - Aged 13-14) Magic Mirror (2023-2025 - Aged 12-14) Sudoku Solver (2023 - Aged 12) Picar S (2023-2025 - Aged 12-14) Safe (2021 - Aged 10) Wildlife Camera (2022 - Aged 11) Morse Code Translator (2021 - Aged 10) CamJam Robot (2022 - Aged 11)","title":"Gallery"},{"location":"gallery/#my-projects","text":"Chess Bot (2025 - Aged 14) CPU (2025 - Aged 14) WER 2025 (2025 - Aged 14) Light Fantastic (2023-2025 - Aged 12-14) QR Code Generator (2024 - Aged 13) Laptop (2023-2025 - Aged 12-14) Scripted Journeys (2024-2025 - Aged 13-14) Magic Mirror (2023-2025 - Aged 12-14) Sudoku Solver (2023 - Aged 12) Picar S (2023-2025 - Aged 12-14) Safe (2021 - Aged 10) Wildlife Camera (2022 - Aged 11) Morse Code Translator (2021 - Aged 10) CamJam Robot (2022 - Aged 11)","title":"My Projects"},{"location":"digital_making/laptop/","text":"Laptop 2023-2025 - Aged 12-14 Overview I made this fully working miniature laptop from scratch. It uses a Raspberry Pi 4, a PiTFT touchscreen display, a miniature keyboard and a 3D printed case. It also has a rechargeable battery, but I haven't added an on/off switch yet so it needs to be plugged in. So far, it only boots to CLI but I am confident I can get it working to desktop. Electronics The battery is wrapped in duct tape to stop any possible shorts, then put in between the Pi and the screen. The screen is mounted directly on the Pi's GPIO pins, and has a small breakout of some of the pins. However, I had to bend these so the battery fit in. I am using a PowerBoost 1000C to connect the battery to the computer. The battery's power and ground lines are soldered onto the powerboost. Another pair of wires goes from the powerboost to some of the pins on the PiTFT to power it and the Pi. I also have a small speaker soldered to an amp, but don't yet have the amp's power or data lines connected and I need to add the power switch so I can turn it on and off. The keyboard is just a Rii mini wireless keyboard . All I had to do was plug the dongle into the Pi and it worked. Software The Raspberry Pi has the standard Raspberry Pi OS installed. I have tried to install the display drivers and they half work. It does display to the screen and is the right way up, but it only shows the console. When I use framebuffer tools such as fbi and pygame , it displays to the screen, so I can make keyboard-based Pygame games. However, as there is no X server running the mouse doesn't work. When I have another display hooked up to the HDMI ports, then it and the PiTFT have the exact same output until I run startx , then the PiTFT freezes, and only the HDMI display works until I end the X session. Case The case is 3D printed, and I found all the parts online here . I didn't have to do any CAD. However, because of the resolution of my printer, the screw threads didn't print properly, so I am holding the back on with tape. Also, the Pi can't be screwed into the holes so I have to design and print something to keep it from falling out. Challenges There were a number of challenges in making this project, some of which I haven't solved yet. The first one was that I used a PowerBoost 1000 instead of a PowerBoost 1000C, so I had no Micro USB charging port. I didn't even realise this until quite a long way into the project, when I tried to charge the battery and found I couldn't. I had to buy a new one, desolder/cut off wires from the old one and resolder the new one. The next (current) challenge is figuring out how to mirror the HDMI output to /dev/fb1 which is the screen's framebuffer.","title":"Laptop"},{"location":"digital_making/laptop/#laptop","text":"2023-2025 - Aged 12-14","title":"Laptop"},{"location":"digital_making/laptop/#overview","text":"I made this fully working miniature laptop from scratch. It uses a Raspberry Pi 4, a PiTFT touchscreen display, a miniature keyboard and a 3D printed case. It also has a rechargeable battery, but I haven't added an on/off switch yet so it needs to be plugged in. So far, it only boots to CLI but I am confident I can get it working to desktop.","title":"Overview"},{"location":"digital_making/laptop/#electronics","text":"The battery is wrapped in duct tape to stop any possible shorts, then put in between the Pi and the screen. The screen is mounted directly on the Pi's GPIO pins, and has a small breakout of some of the pins. However, I had to bend these so the battery fit in. I am using a PowerBoost 1000C to connect the battery to the computer. The battery's power and ground lines are soldered onto the powerboost. Another pair of wires goes from the powerboost to some of the pins on the PiTFT to power it and the Pi. I also have a small speaker soldered to an amp, but don't yet have the amp's power or data lines connected and I need to add the power switch so I can turn it on and off. The keyboard is just a Rii mini wireless keyboard . All I had to do was plug the dongle into the Pi and it worked.","title":"Electronics"},{"location":"digital_making/laptop/#software","text":"The Raspberry Pi has the standard Raspberry Pi OS installed. I have tried to install the display drivers and they half work. It does display to the screen and is the right way up, but it only shows the console. When I use framebuffer tools such as fbi and pygame , it displays to the screen, so I can make keyboard-based Pygame games. However, as there is no X server running the mouse doesn't work. When I have another display hooked up to the HDMI ports, then it and the PiTFT have the exact same output until I run startx , then the PiTFT freezes, and only the HDMI display works until I end the X session.","title":"Software"},{"location":"digital_making/laptop/#case","text":"The case is 3D printed, and I found all the parts online here . I didn't have to do any CAD. However, because of the resolution of my printer, the screw threads didn't print properly, so I am holding the back on with tape. Also, the Pi can't be screwed into the holes so I have to design and print something to keep it from falling out.","title":"Case"},{"location":"digital_making/laptop/#challenges","text":"There were a number of challenges in making this project, some of which I haven't solved yet. The first one was that I used a PowerBoost 1000 instead of a PowerBoost 1000C, so I had no Micro USB charging port. I didn't even realise this until quite a long way into the project, when I tried to charge the battery and found I couldn't. I had to buy a new one, desolder/cut off wires from the old one and resolder the new one. The next (current) challenge is figuring out how to mirror the HDMI output to /dev/fb1 which is the screen's framebuffer.","title":"Challenges"},{"location":"digital_making/light_fantastic/","text":"Light Fantastic 2023-2025 - Aged 12-14 Overview The Light Fantastic is a project from the book Raspberry Pi Projects for Dummies . It is a 4x4 RGB illuminated button matrix, so 16 individually addressable RGB lights under 16 buttons. In the book, they run a ribbon cable to a raspberry pi outside the box, but as the Pico has now been released, I am using that inside the box. It is now mostly working, but there are still 2 buttons that don't register presses. How Was It Built? I took a pre-made PCB and altered it I soldered a bunch of LEDs and diodes I attached wires around the different ports I attached the wires to the Raspberry Pi Pico I programmed it I put it in a case PCB Altering First of all, I took the Sparkfun button pad pcb (target=\"_blank\" rel=\"noopener\"). This was designed for this sort of project. However, I was going to use Neopixels, not standard RGB LEDs, so it needed some modification. I cut a whole load of traces on the board to prevent short-circuits. I also accidentally cut a trace that I wasn't supposed to so I had to solder a wire across it. LEDs and Diodes This project needed 16 WS2812B LEDs for the illumination and 16 diodes to prevent crashing and possible damage when 2 or more buttons are pressed at once. I soldered the diodes first, but not very well as it was one of my first times soldering. I then did the LEDs, which was a bit better because I had got more experience in my break for a few months. They weren't much better, though, as the pins were much closer together so were much harder to do. Wiring it Up The first wires I did were the Din wire, through a resistor, to the first LED. I then did the Dout of the last LED of each row to the Din of the first LED on the next row. Next, I did the power and ground rails for the LEDs. I was then able to test them. I found that 2 of the Neopixels were just broken so we had to get some more, but after that it worked! I then had to do the 8 wires for the button matrix which went quite well. Pico Connection I didn't really feel confident soldering wires straight to the Pico, and I also might want to remove it and use it for something else later. My solution to this was to buy some 2.54mm pitch screw terminals and solder only the pins I needed. This worked really well and when I attached the wires to them they just worked. Programming I am programming in CircuitPython as I don't want to download a new firmware file for every update to the code. I made a main library that handles the actual interfacing with the board. It reveals functions to set LEDs to values based on either their index or xy coordinates, clear the LEDs, write changes, get buttons pressed, wait for a button to be pressed and get multiple button presses. I can then use that to make games for it. So far, I have only made a Lights Out game, where you have to turn all of the LEDs off. When you push a button, it inverts it and the 4 buttons it's touching. There are multiple levels, each one requiring more and more presses to win. Case It was quite fragile outside of a case, so I designed a case in TinkerCAD and 3D printed it. I made it in two parts so I could put the electronics inside, but I didn't think how to close it. Currently, the two parts are held together by tape. Progression This was one of the main defining projects for me, as it taught me a lot. When I started, I didn't really know how to solder or how electronics worked, and I could only program in simple Python. Now, I can solder quite well, have a deep understanding of how electric devices work, and I can program microcontrollers to do what I want. Challenges I did come across multiple challenges when making this. The first main one was when I cut the wrong PCB trace and had to solder a wire across it. Then the pins of the LEDs were too close for me to solder at that skill level, so I had to do other things for a long time before I was able to do it. I then had trouble working out how to attach the wires to the Pico, which I only answered in early 2025. Finally, in addition to games, I wanted it to be used as a sort of macro keyboard. This is why I used CircuitPython. When it turned on, it would try to connect to the computer to register itself as a keyboard. However, this mean it would crash when it isn't connected to a computer, for example if I just wanted to play a game on it. I couldn't debug this as it only crashed when it is not connected to a serial port. Currently, I am just adding games to it as this is the main aim of it anyway, but I will come back to this problem eventually. I reckon I will have to connect it to my Raspberry Pi via UART instead of USB to debug it.","title":"Light Fantastic"},{"location":"digital_making/light_fantastic/#light-fantastic","text":"2023-2025 - Aged 12-14","title":"Light Fantastic"},{"location":"digital_making/light_fantastic/#overview","text":"The Light Fantastic is a project from the book Raspberry Pi Projects for Dummies . It is a 4x4 RGB illuminated button matrix, so 16 individually addressable RGB lights under 16 buttons. In the book, they run a ribbon cable to a raspberry pi outside the box, but as the Pico has now been released, I am using that inside the box. It is now mostly working, but there are still 2 buttons that don't register presses.","title":"Overview"},{"location":"digital_making/light_fantastic/#how-was-it-built","text":"I took a pre-made PCB and altered it I soldered a bunch of LEDs and diodes I attached wires around the different ports I attached the wires to the Raspberry Pi Pico I programmed it I put it in a case","title":"How Was It Built?"},{"location":"digital_making/light_fantastic/#pcb-altering","text":"First of all, I took the Sparkfun button pad pcb (target=\"_blank\" rel=\"noopener\"). This was designed for this sort of project. However, I was going to use Neopixels, not standard RGB LEDs, so it needed some modification. I cut a whole load of traces on the board to prevent short-circuits. I also accidentally cut a trace that I wasn't supposed to so I had to solder a wire across it.","title":"PCB Altering"},{"location":"digital_making/light_fantastic/#leds-and-diodes","text":"This project needed 16 WS2812B LEDs for the illumination and 16 diodes to prevent crashing and possible damage when 2 or more buttons are pressed at once. I soldered the diodes first, but not very well as it was one of my first times soldering. I then did the LEDs, which was a bit better because I had got more experience in my break for a few months. They weren't much better, though, as the pins were much closer together so were much harder to do.","title":"LEDs and Diodes"},{"location":"digital_making/light_fantastic/#wiring-it-up","text":"The first wires I did were the Din wire, through a resistor, to the first LED. I then did the Dout of the last LED of each row to the Din of the first LED on the next row. Next, I did the power and ground rails for the LEDs. I was then able to test them. I found that 2 of the Neopixels were just broken so we had to get some more, but after that it worked! I then had to do the 8 wires for the button matrix which went quite well.","title":"Wiring it Up"},{"location":"digital_making/light_fantastic/#pico-connection","text":"I didn't really feel confident soldering wires straight to the Pico, and I also might want to remove it and use it for something else later. My solution to this was to buy some 2.54mm pitch screw terminals and solder only the pins I needed. This worked really well and when I attached the wires to them they just worked.","title":"Pico Connection"},{"location":"digital_making/light_fantastic/#programming","text":"I am programming in CircuitPython as I don't want to download a new firmware file for every update to the code. I made a main library that handles the actual interfacing with the board. It reveals functions to set LEDs to values based on either their index or xy coordinates, clear the LEDs, write changes, get buttons pressed, wait for a button to be pressed and get multiple button presses. I can then use that to make games for it. So far, I have only made a Lights Out game, where you have to turn all of the LEDs off. When you push a button, it inverts it and the 4 buttons it's touching. There are multiple levels, each one requiring more and more presses to win.","title":"Programming"},{"location":"digital_making/light_fantastic/#case","text":"It was quite fragile outside of a case, so I designed a case in TinkerCAD and 3D printed it. I made it in two parts so I could put the electronics inside, but I didn't think how to close it. Currently, the two parts are held together by tape.","title":"Case"},{"location":"digital_making/light_fantastic/#progression","text":"This was one of the main defining projects for me, as it taught me a lot. When I started, I didn't really know how to solder or how electronics worked, and I could only program in simple Python. Now, I can solder quite well, have a deep understanding of how electric devices work, and I can program microcontrollers to do what I want.","title":"Progression"},{"location":"digital_making/light_fantastic/#challenges","text":"I did come across multiple challenges when making this. The first main one was when I cut the wrong PCB trace and had to solder a wire across it. Then the pins of the LEDs were too close for me to solder at that skill level, so I had to do other things for a long time before I was able to do it. I then had trouble working out how to attach the wires to the Pico, which I only answered in early 2025. Finally, in addition to games, I wanted it to be used as a sort of macro keyboard. This is why I used CircuitPython. When it turned on, it would try to connect to the computer to register itself as a keyboard. However, this mean it would crash when it isn't connected to a computer, for example if I just wanted to play a game on it. I couldn't debug this as it only crashed when it is not connected to a serial port. Currently, I am just adding games to it as this is the main aim of it anyway, but I will come back to this problem eventually. I reckon I will have to connect it to my Raspberry Pi via UART instead of USB to debug it.","title":"Challenges"},{"location":"digital_making/magic_mirror/","text":"Magic Mirror 2023-2025 - Aged 12-14 Overview A magic mirror is a mirror that has text and possibly images displayed on it. They typically work with a 2-way mirror where you can see through it as well as the reflection, and then just placing a screen behind it. I got the inspiration to make one from the MagPi issue #93 , where they finished a guide on creating your own. This project involved learning a new programming language, 3D CAD, API calls and Linux setup. Electronics I chose a Raspberry Pi here because it made it simple to run a display, had a full Linux OS and I already knew how to use them. I got a Raspberry Pi Touch Display which was very much overkill as once the project's completed, you are never going to touch it (it'll be behind a mirror), but I already had one so decided to use it. I then just got a Raspberry Pi 3, connected it to the screen, and moved on to software. Software First, I got the MagicMirror\u00b2 software installed and set up. By default, it had a few useful modules installed, such as the time and the weather, but I also decided to change most of them. I removed the 'compliment' module, because the screen I used was too small, and then found a few other ones online that I liked. Once I had finished customising the display, the modules I had were: Clock Weather News Feed Facts Weather Effects Advent Calendar I left it at this stage for a few months, then I decided to go a step further. I learnt how to program in JavaScript, then discovered how to use the MagicMirror\u00b2 API to create my own modules. The first one I made gave you a random Pokemon each day, similar to this one but with less information. I made a few more small ones, but I haven't yet made a big one as the case problems put me off this project. Case Surprisingly, this was the bit that took the longest. I measured the precise dimensions of the glass and the screen, and designed a case that would fit it perfectly. I then 3D printed it, which took almost 24 hours to complete, but when I tested it, it didn't fit! I had designed it to fit the mirror so neatly that the printer squishing the plastic as it moved made it too narrow! This put me off 3D printing far more than it should, and I just put the mirror in a shoebox and forgot about it for a year. Recently (late 2025), I rediscovered it and made a new case for it using a simple trick I learnt when making my Light Fantastic , where you increase the capacity of the case by a few mm in each direction. I printed it again (in 2 parts as the first one failed near the end) and it worked really well. Challenges The most challenging part was making the case, as when I first designed it, I forgot to account for the printer's tolerance, so the mirror simply would not fit. At first, I wasn't sure why this happened, but I eventually measured the dimensions of the inside of the case and found that they were about a millimeter too small. In addition, creating my own modules for the mirror meant that I had to learn a whole new language first, as I had only touched JavaScript a few times before, and now I needed to learn DOM modelling, external API access, timeouts, status codes and a whole load more. What I Learned How two-way mirrors work in display projects Setting up and configuring Linux-based systems Customising and extending existing open-source software Writing JavaScript modules using an existing API Designing 3D-printed parts with appropriate tolerances Learning from failed designs and improving them through iteration","title":"Magic Mirror"},{"location":"digital_making/magic_mirror/#magic-mirror","text":"2023-2025 - Aged 12-14","title":"Magic Mirror"},{"location":"digital_making/magic_mirror/#overview","text":"A magic mirror is a mirror that has text and possibly images displayed on it. They typically work with a 2-way mirror where you can see through it as well as the reflection, and then just placing a screen behind it. I got the inspiration to make one from the MagPi issue #93 , where they finished a guide on creating your own. This project involved learning a new programming language, 3D CAD, API calls and Linux setup.","title":"Overview"},{"location":"digital_making/magic_mirror/#electronics","text":"I chose a Raspberry Pi here because it made it simple to run a display, had a full Linux OS and I already knew how to use them. I got a Raspberry Pi Touch Display which was very much overkill as once the project's completed, you are never going to touch it (it'll be behind a mirror), but I already had one so decided to use it. I then just got a Raspberry Pi 3, connected it to the screen, and moved on to software.","title":"Electronics"},{"location":"digital_making/magic_mirror/#software","text":"First, I got the MagicMirror\u00b2 software installed and set up. By default, it had a few useful modules installed, such as the time and the weather, but I also decided to change most of them. I removed the 'compliment' module, because the screen I used was too small, and then found a few other ones online that I liked. Once I had finished customising the display, the modules I had were: Clock Weather News Feed Facts Weather Effects Advent Calendar I left it at this stage for a few months, then I decided to go a step further. I learnt how to program in JavaScript, then discovered how to use the MagicMirror\u00b2 API to create my own modules. The first one I made gave you a random Pokemon each day, similar to this one but with less information. I made a few more small ones, but I haven't yet made a big one as the case problems put me off this project.","title":"Software"},{"location":"digital_making/magic_mirror/#case","text":"Surprisingly, this was the bit that took the longest. I measured the precise dimensions of the glass and the screen, and designed a case that would fit it perfectly. I then 3D printed it, which took almost 24 hours to complete, but when I tested it, it didn't fit! I had designed it to fit the mirror so neatly that the printer squishing the plastic as it moved made it too narrow! This put me off 3D printing far more than it should, and I just put the mirror in a shoebox and forgot about it for a year. Recently (late 2025), I rediscovered it and made a new case for it using a simple trick I learnt when making my Light Fantastic , where you increase the capacity of the case by a few mm in each direction. I printed it again (in 2 parts as the first one failed near the end) and it worked really well.","title":"Case"},{"location":"digital_making/magic_mirror/#challenges","text":"The most challenging part was making the case, as when I first designed it, I forgot to account for the printer's tolerance, so the mirror simply would not fit. At first, I wasn't sure why this happened, but I eventually measured the dimensions of the inside of the case and found that they were about a millimeter too small. In addition, creating my own modules for the mirror meant that I had to learn a whole new language first, as I had only touched JavaScript a few times before, and now I needed to learn DOM modelling, external API access, timeouts, status codes and a whole load more.","title":"Challenges"},{"location":"digital_making/magic_mirror/#what-i-learned","text":"How two-way mirrors work in display projects Setting up and configuring Linux-based systems Customising and extending existing open-source software Writing JavaScript modules using an existing API Designing 3D-printed parts with appropriate tolerances Learning from failed designs and improving them through iteration","title":"What I Learned"},{"location":"digital_making/wildlife_camera/","text":"Wildlife Camera 2022 - Aged 11 Details coming soon!","title":"Wildlife Camera"},{"location":"digital_making/wildlife_camera/#wildlife-camera","text":"2022 - Aged 11","title":"Wildlife Camera"},{"location":"digital_making/wildlife_camera/#details-coming-soon","text":"","title":"Details coming soon!"},{"location":"electronics/safe/","text":"Safe 2021 - Aged 10 My finished safe Overview This is my first large electronics project. It isn't very complex by the standards of my other projects but it is on here because I had basically never done this sort of thing before. It is a homemade safe with a 4-bit code to unlock the electromagnet. I sawed the MDF sheets and screwed them together, before adding an electromagnet inside and some metal washers on the door. On top are the electronics, which consist of a 4.5V battery pack, a DIP (Dual Inline Package) switch, 4 AND gates, 6 NOT gates, a transistor, a relay and a 12V battery. A schematic diagram of how the electronics work My Aim I wanted to make a safe with a door that locked, and you could only open it if you know the code. I mostly achieved that goal, as there is some resistance to the door when it is locked, but none when unlocked. However, it isn't a very safe safe as the electromagnet isn't very strong so you can just pull the door open, or you could just unplug the batteries. How it works There are 4 switches, each of which is on or off, The 1st, 3rd and 4th switches are inverted, The outputs of the inverters and the 2nd switch are ANDed together. This means that the output of this is only on if the 1st input is off, the 2nd input is on, and the 3rd and 4th inputs are off. The output of this switches a transistor to increase current, The output of the transistor switches a relay to increase voltage, The relay switches the electromagnet, The electromagnet pulls of washers glued to the inside of the door to close it Challenges It was my first large DIY project so I had to learn to use a saw and a drill safely, as well as the electronics. The main problem I had with the electronics was that I had forgotten pull-down resistors, so the inputs were floating (no definite value) when the switches were off. I eventually Googled the problem and put the resistors in and it worked, but I didn't realise why until I started making my CPU . What I would change If I built it again now, I would change a few things: I would use a solenoid pushing into a hole instead of an electromagnet. I would use a PCB to stop people unplugging wires. I would place all of the electronics inside the safe, with only the switches on top. I would use more switches, e.g. a 10-bit code","title":"Safe"},{"location":"electronics/safe/#safe","text":"2021 - Aged 10 My finished safe","title":"Safe"},{"location":"electronics/safe/#overview","text":"This is my first large electronics project. It isn't very complex by the standards of my other projects but it is on here because I had basically never done this sort of thing before. It is a homemade safe with a 4-bit code to unlock the electromagnet. I sawed the MDF sheets and screwed them together, before adding an electromagnet inside and some metal washers on the door. On top are the electronics, which consist of a 4.5V battery pack, a DIP (Dual Inline Package) switch, 4 AND gates, 6 NOT gates, a transistor, a relay and a 12V battery. A schematic diagram of how the electronics work","title":"Overview"},{"location":"electronics/safe/#my-aim","text":"I wanted to make a safe with a door that locked, and you could only open it if you know the code. I mostly achieved that goal, as there is some resistance to the door when it is locked, but none when unlocked. However, it isn't a very safe safe as the electromagnet isn't very strong so you can just pull the door open, or you could just unplug the batteries.","title":"My Aim"},{"location":"electronics/safe/#how-it-works","text":"There are 4 switches, each of which is on or off, The 1st, 3rd and 4th switches are inverted, The outputs of the inverters and the 2nd switch are ANDed together. This means that the output of this is only on if the 1st input is off, the 2nd input is on, and the 3rd and 4th inputs are off. The output of this switches a transistor to increase current, The output of the transistor switches a relay to increase voltage, The relay switches the electromagnet, The electromagnet pulls of washers glued to the inside of the door to close it","title":"How it works"},{"location":"electronics/safe/#challenges","text":"It was my first large DIY project so I had to learn to use a saw and a drill safely, as well as the electronics. The main problem I had with the electronics was that I had forgotten pull-down resistors, so the inputs were floating (no definite value) when the switches were off. I eventually Googled the problem and put the resistors in and it worked, but I didn't realise why until I started making my CPU .","title":"Challenges"},{"location":"electronics/safe/#what-i-would-change","text":"If I built it again now, I would change a few things: I would use a solenoid pushing into a hole instead of an electromagnet. I would use a PCB to stop people unplugging wires. I would place all of the electronics inside the safe, with only the switches on top. I would use more switches, e.g. a 10-bit code","title":"What I would change"},{"location":"electronics/cpu/alu/","text":"ALU 2025 - Aged 14 An image of my ALU Overview Doing maths is one of the main purposes of a CPU, and the ALU (Arithmetic and Logic Unit) is the bit that actually does it. As with the rest of my CPU, this is less powerful than most modern ones. It has 4 modes, add, subtract, NOR, and right shift (divide by two, ignore any remainder). I am making it on 2 breadboards: the top one to show the inputs, output, and setting, as well as switching between modes, and the bottom one to actually do the maths. The top breadboard has 26 LEDs on it, and will have 2 8-bit 2:1 multiplexers. The bottom one has 2 quad-XOR gates, 2 4-bit adders and 2 quad-NOR gates. The right shift is simply connecting the inputs to the output in a different place. The LEDs This was a simple part. All I had to do was solder down a whole load of green and blue LEDs, some resistors and some wires. Despite this, I still came across a few issues when prototyping. The current-limiting resistors I used were 470R resistors, which pulled too much current and so the chips to actually use the data sometimes didn't have enough current to know if it was a 1 or a 0. This meant the built-in pull-up resistors took over and the actual data was ignored. I fixed this by using 10kR resistors instead. Adding and Subtracting I used 4 chips for this, 2 adders and 2 XOR chips. Adding 2 numbers is simple: just feed them into the adders (I used 4-bit adders instead of making my own because it's cheaper). Subtracting is harder, as you have to negate the second number and then add them together. This is essentially just doing 5 + -3 instead of 5 - 3. In binary, negative numbers are expressed in two's complement, which you convert into by inverting all of the bits and adding 1. I accomplished this by using a single subtract signal (this is actually the least significant bit of the setting as the setting for add is 00, so it won't subtract, subtract is 01 so it will subtract, and the other two don't matter as they won't use the adders anyway). The subtract signal is XORed with all of the data bits for the second number, as any number XOR 0 is itself, and any number XOR 1 is itself inverted. The subtract signal then also goes to the carry in of the first adder, so it will add one. This setup means that the second number will always go through the XOR gates, simplifying the wiring even if it does make the logic more complex. NOR Operation This was a simple bit, as I just connected the inputs of the ALU to the inputs of the NOR gates. I came across no problems, and it was straightforward. Right Shift I haven't done this yet, as it will be very simple. I don't have the multiplexers yet so I have to wait to connect the inputs to one. Mode Selection So far, I have added the final 2:1 multiplexer, which will select between the adding/subtracting and the NOR-ing/right shifting. The select signal, outputs and A inputs have been wired up and connected. Next, I will add the multiplexers that will choose between NOR and right shift, but first I need to work out how to actually fit them on the breadboard! Challenges I didn't come across many challenges (yet) when making this. The main one was the weak resistors pulling all of the current so the chips registered a high input, but this was easily fixed. I still have the multiplexers to add though, so I may come across more problems.","title":"ALU"},{"location":"electronics/cpu/alu/#alu","text":"2025 - Aged 14 An image of my ALU","title":"ALU"},{"location":"electronics/cpu/alu/#overview","text":"Doing maths is one of the main purposes of a CPU, and the ALU (Arithmetic and Logic Unit) is the bit that actually does it. As with the rest of my CPU, this is less powerful than most modern ones. It has 4 modes, add, subtract, NOR, and right shift (divide by two, ignore any remainder). I am making it on 2 breadboards: the top one to show the inputs, output, and setting, as well as switching between modes, and the bottom one to actually do the maths. The top breadboard has 26 LEDs on it, and will have 2 8-bit 2:1 multiplexers. The bottom one has 2 quad-XOR gates, 2 4-bit adders and 2 quad-NOR gates. The right shift is simply connecting the inputs to the output in a different place.","title":"Overview"},{"location":"electronics/cpu/alu/#the-leds","text":"This was a simple part. All I had to do was solder down a whole load of green and blue LEDs, some resistors and some wires. Despite this, I still came across a few issues when prototyping. The current-limiting resistors I used were 470R resistors, which pulled too much current and so the chips to actually use the data sometimes didn't have enough current to know if it was a 1 or a 0. This meant the built-in pull-up resistors took over and the actual data was ignored. I fixed this by using 10kR resistors instead.","title":"The LEDs"},{"location":"electronics/cpu/alu/#adding-and-subtracting","text":"I used 4 chips for this, 2 adders and 2 XOR chips. Adding 2 numbers is simple: just feed them into the adders (I used 4-bit adders instead of making my own because it's cheaper). Subtracting is harder, as you have to negate the second number and then add them together. This is essentially just doing 5 + -3 instead of 5 - 3. In binary, negative numbers are expressed in two's complement, which you convert into by inverting all of the bits and adding 1. I accomplished this by using a single subtract signal (this is actually the least significant bit of the setting as the setting for add is 00, so it won't subtract, subtract is 01 so it will subtract, and the other two don't matter as they won't use the adders anyway). The subtract signal is XORed with all of the data bits for the second number, as any number XOR 0 is itself, and any number XOR 1 is itself inverted. The subtract signal then also goes to the carry in of the first adder, so it will add one. This setup means that the second number will always go through the XOR gates, simplifying the wiring even if it does make the logic more complex.","title":"Adding and Subtracting"},{"location":"electronics/cpu/alu/#nor-operation","text":"This was a simple bit, as I just connected the inputs of the ALU to the inputs of the NOR gates. I came across no problems, and it was straightforward.","title":"NOR Operation"},{"location":"electronics/cpu/alu/#right-shift","text":"I haven't done this yet, as it will be very simple. I don't have the multiplexers yet so I have to wait to connect the inputs to one.","title":"Right Shift"},{"location":"electronics/cpu/alu/#mode-selection","text":"So far, I have added the final 2:1 multiplexer, which will select between the adding/subtracting and the NOR-ing/right shifting. The select signal, outputs and A inputs have been wired up and connected. Next, I will add the multiplexers that will choose between NOR and right shift, but first I need to work out how to actually fit them on the breadboard!","title":"Mode Selection"},{"location":"electronics/cpu/alu/#challenges","text":"I didn't come across many challenges (yet) when making this. The main one was the weak resistors pulling all of the current so the chips registered a high input, but this was easily fixed. I still have the multiplexers to add though, so I may come across more problems.","title":"Challenges"},{"location":"electronics/cpu/branching/","text":"","title":"Branching"},{"location":"electronics/cpu/clock/","text":"CPU Clock 2025 - Aged 14 An image of my CPU clock Overview In a CPU, it needs something to tell it when to do things. This is the clock. Most computers run at a speed of around 3GHz (3 billion cycles per second). Mine will run at up to 48Hz. The clock is made of 4 parts: the automatic clock, the manual clock, the mode selector and the clock logic. The automatic clock just turns on and off again at a variable speed, set by a potentiometer (a dial). The manual clock pulses whenever you push a button, mainly for debugging and testing. The mode selector lets you pick which mode to use and the clock logic actually does the switching. The Automatic Clock This was the simplest bit, as it was just a 555 timer in astable mode. I used a potentiometer between pins 6 & 7 so I could change the speed. The rest of the connections were quite straightforward. The Manual Clock This was far more difficult than I had anticipated, as buttons often bounce, triggering multiple pulses when you only wanted one. I had to use a 555 timer in monostable mode, so when you push the button, it turns on and 0.3 seconds after you release the button, it turns off. This means that if the button does bounce, the extra pulses will be caught in the 0.3 seconds before it turns off. The Mode Selector Both this and the clock logic could be replaced by a simple 3-pin switch, but again you get the problem of button bounce. Instead, I had to use a 555 timer in bistable mode, where you can push a button once and turn it on, and push the button again and turn it off. This was the hardest part, and I took a while to get it working. After a while, I found that you should add a 100nF capacitor between pin 5 & ground, so I did and it worked. The Clock Logic Now that I have 3 signals (automatic clock, manual clock and mode), I had to make a circuit to switch between auto and manual modes. This wasn't too hard. First, I had to invert the mode so I had a mode signal and a not mode signal. I then ANDed the auto clock signal with the not mode signal, and the manual clock with the mode signal. I then ORed the two outputs together with a homemade diode OR gate. This was my first problem, as it either gave a high output or a floating output, which was registered as high by the next gate. I fixed it by adding some pull-down resistors. Finally, the output of that gets ANDed with the inverted halt signal to get the output. Challenges When testing the clock module, the circuit that should have made the bistable 555 timer didn't work, so I had to experiment with a lot of different methods. I eventually got it working by tying a 0.1\u00b5F capacitor across pin 5 and ground, but weirdly when I soldered it down, it worked without the capacitor. I still added it in just in case. In addition, I had a problem with floating outputs of the diode OR gate, but I fixed it with a pull-down resistor. However, sometimes now when it is on the automatic clock, it just stays off. I think I just need to reduce the strength of the resistors, but I haven't done this yet.","title":"Clock Module"},{"location":"electronics/cpu/clock/#cpu-clock","text":"2025 - Aged 14 An image of my CPU clock","title":"CPU Clock"},{"location":"electronics/cpu/clock/#overview","text":"In a CPU, it needs something to tell it when to do things. This is the clock. Most computers run at a speed of around 3GHz (3 billion cycles per second). Mine will run at up to 48Hz. The clock is made of 4 parts: the automatic clock, the manual clock, the mode selector and the clock logic. The automatic clock just turns on and off again at a variable speed, set by a potentiometer (a dial). The manual clock pulses whenever you push a button, mainly for debugging and testing. The mode selector lets you pick which mode to use and the clock logic actually does the switching.","title":"Overview"},{"location":"electronics/cpu/clock/#the-automatic-clock","text":"This was the simplest bit, as it was just a 555 timer in astable mode. I used a potentiometer between pins 6 & 7 so I could change the speed. The rest of the connections were quite straightforward.","title":"The Automatic Clock"},{"location":"electronics/cpu/clock/#the-manual-clock","text":"This was far more difficult than I had anticipated, as buttons often bounce, triggering multiple pulses when you only wanted one. I had to use a 555 timer in monostable mode, so when you push the button, it turns on and 0.3 seconds after you release the button, it turns off. This means that if the button does bounce, the extra pulses will be caught in the 0.3 seconds before it turns off.","title":"The Manual Clock"},{"location":"electronics/cpu/clock/#the-mode-selector","text":"Both this and the clock logic could be replaced by a simple 3-pin switch, but again you get the problem of button bounce. Instead, I had to use a 555 timer in bistable mode, where you can push a button once and turn it on, and push the button again and turn it off. This was the hardest part, and I took a while to get it working. After a while, I found that you should add a 100nF capacitor between pin 5 & ground, so I did and it worked.","title":"The Mode Selector"},{"location":"electronics/cpu/clock/#the-clock-logic","text":"Now that I have 3 signals (automatic clock, manual clock and mode), I had to make a circuit to switch between auto and manual modes. This wasn't too hard. First, I had to invert the mode so I had a mode signal and a not mode signal. I then ANDed the auto clock signal with the not mode signal, and the manual clock with the mode signal. I then ORed the two outputs together with a homemade diode OR gate. This was my first problem, as it either gave a high output or a floating output, which was registered as high by the next gate. I fixed it by adding some pull-down resistors. Finally, the output of that gets ANDed with the inverted halt signal to get the output.","title":"The Clock Logic"},{"location":"electronics/cpu/clock/#challenges","text":"When testing the clock module, the circuit that should have made the bistable 555 timer didn't work, so I had to experiment with a lot of different methods. I eventually got it working by tying a 0.1\u00b5F capacitor across pin 5 and ground, but weirdly when I soldered it down, it worked without the capacitor. I still added it in just in case. In addition, I had a problem with floating outputs of the diode OR gate, but I fixed it with a pull-down resistor. However, sometimes now when it is on the automatic clock, it just stays off. I think I just need to reduce the strength of the resistors, but I haven't done this yet.","title":"Challenges"},{"location":"electronics/cpu/cpu/","text":"CPU 2025 - Aged 14 An image of my CPU so far Overview This is my current project, it is an 8-bit CPU built out of individual ICs (Integrated Circuits). I got the idea in my Computer Science lessons at school, where I learnt how a CPU works and realised that it isn't actually as complex as I thought. I then started to make parts of it to test in Minecraft, before finding Ben Eater's similar project and using that as a guide to making the basic parts of the computer. Specs 6 - 48 Hz variable clock speed 1 core 64kB RAM 16 registers; r0 is a zero register 8-bit maths Von Neumann architecture My Aim I want to make an 8-bit CPU with 16 instructions. It will be fully Turing-complete. It will be able to do maths, store data, jump and branch to other parts of a program, and input and output to other devices. The instruction set I want to implement are adding, subtracting, NORing, right shifting, loading from RAM, storing to RAM, loading from a port, storing to a port, loading immediate values, adding immediate values, jumping around the program, branching to other parts of a program depending on a condition, and halting. How I'm Building It I am making it module by module, first breadboarding it to test it and make sure it works, then soldering it down to a solderable breadboard . So far, I have completed the clock module, and mostly done the ALU. I am soldering the components to the top of the board so you can see them easily and the wires to the bottom of the board, just because I think it looks neater. The back of my CPU clock with all the wires What I'm Learning I am learning LOADS about the internal mechanisms of how computers actually work at the most detailed level, as well as soldering skills, PCB design, and electronic principles such as why pull-up/down resistors are actually necessary. More Details Clock Module ALU","title":"Overview"},{"location":"electronics/cpu/cpu/#cpu","text":"2025 - Aged 14 An image of my CPU so far","title":"CPU"},{"location":"electronics/cpu/cpu/#overview","text":"This is my current project, it is an 8-bit CPU built out of individual ICs (Integrated Circuits). I got the idea in my Computer Science lessons at school, where I learnt how a CPU works and realised that it isn't actually as complex as I thought. I then started to make parts of it to test in Minecraft, before finding Ben Eater's similar project and using that as a guide to making the basic parts of the computer.","title":"Overview"},{"location":"electronics/cpu/cpu/#specs","text":"6 - 48 Hz variable clock speed 1 core 64kB RAM 16 registers; r0 is a zero register 8-bit maths Von Neumann architecture","title":"Specs"},{"location":"electronics/cpu/cpu/#my-aim","text":"I want to make an 8-bit CPU with 16 instructions. It will be fully Turing-complete. It will be able to do maths, store data, jump and branch to other parts of a program, and input and output to other devices. The instruction set I want to implement are adding, subtracting, NORing, right shifting, loading from RAM, storing to RAM, loading from a port, storing to a port, loading immediate values, adding immediate values, jumping around the program, branching to other parts of a program depending on a condition, and halting.","title":"My Aim"},{"location":"electronics/cpu/cpu/#how-im-building-it","text":"I am making it module by module, first breadboarding it to test it and make sure it works, then soldering it down to a solderable breadboard . So far, I have completed the clock module, and mostly done the ALU. I am soldering the components to the top of the board so you can see them easily and the wires to the bottom of the board, just because I think it looks neater. The back of my CPU clock with all the wires","title":"How I'm Building It"},{"location":"electronics/cpu/cpu/#what-im-learning","text":"I am learning LOADS about the internal mechanisms of how computers actually work at the most detailed level, as well as soldering skills, PCB design, and electronic principles such as why pull-up/down resistors are actually necessary.","title":"What I'm Learning"},{"location":"electronics/cpu/cpu/#more-details","text":"Clock Module ALU","title":"More Details"},{"location":"electronics/cpu/ports/","text":"","title":"Ports"},{"location":"electronics/cpu/ram/","text":"RAM 2025 - Aged 14 Details Coming Soon!","title":"CPU"},{"location":"electronics/cpu/ram/#ram","text":"2025 - Aged 14","title":"RAM"},{"location":"electronics/cpu/ram/#details-coming-soon","text":"","title":"Details Coming Soon!"},{"location":"electronics/cpu/registers/","text":"Registers 2025 - Aged 14 Details Coming Soon!","title":"CPU"},{"location":"electronics/cpu/registers/#registers","text":"2025 - Aged 14","title":"Registers"},{"location":"electronics/cpu/registers/#details-coming-soon","text":"","title":"Details Coming Soon!"},{"location":"electronics/cpu/software/","text":"","title":"Software"},{"location":"programming/chess_bot/","text":"Chess Bot 2025 - Aged 14 A Lichess.org game where my bot won Overview I created a Java program that can play chess. It generates all legal moves and evaluates them, giving them points. It then plays the highest-ranking move. I have given it a UCI (Universal Chess Interface) frontend so it can interact with other chess apps. For example, I have given it a Lichess account ( SamFish96 ) and occasionally it is online.You can see the source code on GitHub . Inspiration I've been interested in complex decision making programs for a while, and a chess bot was a suitably complex but not overwhelming introduction to them. How it works It uses an 8x8 array of pieces or empty squares to represent the board. Whenever the chess app tells it that a move has been made, it simulates the move on its own board. When it needs to move one of its pieces, it looks at all of the possible moves that it can make, discards any that put it in check, then evaluates all of them. If it has time, it looks at the next turn or two as well. It then picks the move it thinks is best and plays it. Key Features Generates almost all possible moves. Uses syzygy tablebases for the endgame to ensure perfect moves. Detects checks, checkmates, stalemates and threefold repetition. Automatic detailed logging to see the bot's logic. Interacts with the Lichess bot API to play online. Improvements Add castling and en passant capabilities Increase speed Challenges I learnt a lot about Java, as before I had mainly programmed in Python. In particular, I use interfaces quite a bit. Looking for checks, checkmates, stalemates and other draws was far harder than I had anticipated, but I did eventually manage. Interacting with syzygy tables was a bit too complex for me to do (there are no Java libraries to read them) so I used an existing library called Fathom to do it.","title":"Chess Bot"},{"location":"programming/chess_bot/#chess-bot","text":"2025 - Aged 14 A Lichess.org game where my bot won","title":"Chess Bot"},{"location":"programming/chess_bot/#overview","text":"I created a Java program that can play chess. It generates all legal moves and evaluates them, giving them points. It then plays the highest-ranking move. I have given it a UCI (Universal Chess Interface) frontend so it can interact with other chess apps. For example, I have given it a Lichess account ( SamFish96 ) and occasionally it is online.You can see the source code on GitHub .","title":"Overview"},{"location":"programming/chess_bot/#inspiration","text":"I've been interested in complex decision making programs for a while, and a chess bot was a suitably complex but not overwhelming introduction to them.","title":"Inspiration"},{"location":"programming/chess_bot/#how-it-works","text":"It uses an 8x8 array of pieces or empty squares to represent the board. Whenever the chess app tells it that a move has been made, it simulates the move on its own board. When it needs to move one of its pieces, it looks at all of the possible moves that it can make, discards any that put it in check, then evaluates all of them. If it has time, it looks at the next turn or two as well. It then picks the move it thinks is best and plays it.","title":"How it works"},{"location":"programming/chess_bot/#key-features","text":"Generates almost all possible moves. Uses syzygy tablebases for the endgame to ensure perfect moves. Detects checks, checkmates, stalemates and threefold repetition. Automatic detailed logging to see the bot's logic. Interacts with the Lichess bot API to play online.","title":"Key Features"},{"location":"programming/chess_bot/#improvements","text":"Add castling and en passant capabilities Increase speed","title":"Improvements"},{"location":"programming/chess_bot/#challenges","text":"I learnt a lot about Java, as before I had mainly programmed in Python. In particular, I use interfaces quite a bit. Looking for checks, checkmates, stalemates and other draws was far harder than I had anticipated, but I did eventually manage. Interacting with syzygy tables was a bit too complex for me to do (there are no Java libraries to read them) so I used an existing library called Fathom to do it.","title":"Challenges"},{"location":"programming/morse_code/","text":"Morse Code Translator 2021 - Aged 10 Details coming soon!","title":"Morse Code Translator"},{"location":"programming/morse_code/#morse-code-translator","text":"2021 - Aged 10","title":"Morse Code Translator"},{"location":"programming/morse_code/#details-coming-soon","text":"","title":"Details coming soon!"},{"location":"programming/qr_code_generator/","text":"QR Code Generator 2024 - Aged 13 Part of the code and the ouput of the QR code generator Overview I got the inspiration for this project because QR codes are everywhere but very few people actually think about how they work. I then found an amazing guide that showed every step. QR codes are far more complicated than you would think, mostly due to the error-correction. You can imagine that if you scan a QR code in not ideal conditions, then the camera may misread one or two pixels. This means we need error correction, which is really complex! The code is on my Github . What It Does It takes a line of text as input from the user, then generates the QR code, saves it as a temporary file and opens it in your default image viewer. From there you can save it somewhere else or share it. Technical Summary It is made of almost 700 lines of Python code split over 9 files. I have used no external modules relating to QR codes, only pillow for graphics, copy to duplicate it and tempfile to save the image. It generates a v5 error level Q alphanumeric QR code, which can hold 87 characters. Steps There are multiple steps in making a QR code: Encode the text in a particular text encoding (ISO 8859-1) Generate error correction codewords Interleave the data and error codewords to make a final binary string Place the individual bits of the binary string in the correct places Apply the mask that makes the QR code easier to read Add constant elements (e.g. the corners) Render Encoding This is one of the simplest steps, as all you have to do is connect the mode string (0100 for text) to the length of the string in binary. You then have to convert each character in the text to the ISO 8859-1 standard. This is easier than I thought it was going to be as it is the standard that Python's chr() function uses. After that, you just need to fill out the rest of the space with a repeating pattern. Error Correction This is by far the hardest part of the QR code. It has quite a lot of maths involved, including polynomial long division in a Galois Field 256. You have to convert the data string to a message polynomial and get a generator polynomial. You then have to divide the message polynomial by the generator polynomial, and the coefficients of the remainder polynomial are the error correction codewords. Structuring You have to break the data codewords into blocks, then interleave the first codeword from the first block, followed by the first from the second block and so on. Once you have done the first codeword from each block, you then move onto the second from each block. Once you have done all the data, you then do the same with the error correction codewords. You then need to add a certain number of zeroes to the end so the QR code will be full. Placement This is a relatively simple part, although still more complex than you would imagine as there are a number of pixels that you have to avoid. You just start at the bottom-right of the QR code and work your way up in a zig-zag pattern, avoiding all of the reserved areas. Masks Occasionally, when you make a QR code, there will be areas of data that look like special symbols such as the corner patterns. This would really confuse the scanner, so you have to apply a mask. These are just lists of which pixels to invert. You have to apply all of them and evaluate which is the best (i.e. has the fewest confusing patterns) then apply that one. Constants This is the simplest bit as most of it is pre-set. You have to add the corners, borders, alignment patterns, timing patterns, dark module and the format information areas. The format information needs to be generated but isn't hard. The format string is mostly the same for my codes as I have only one type of QR code. The only bit that changes is the mask pattern used. You then have to error-correct it and add it. Render For this, I use Python's pillow library to work with images. Each pixel of the QR code is 10 pixels wide in the image so when I open it in an image viewer, it doesn't blur the edges between pixels. I just loop over each pixel in the QR code and place a 10x10 square of whatever colour it is in the image. Challenges The hardest bit of this was the error correction, as at the time I didn't even know what a polynomial was or how binary worked. I had to write code to do maths with strings in weird number systems. It took me about a week to make 160 lines of code, and another week to test and debug it!","title":"QR Code Generator"},{"location":"programming/qr_code_generator/#qr-code-generator","text":"2024 - Aged 13 Part of the code and the ouput of the QR code generator","title":"QR Code Generator"},{"location":"programming/qr_code_generator/#overview","text":"I got the inspiration for this project because QR codes are everywhere but very few people actually think about how they work. I then found an amazing guide that showed every step. QR codes are far more complicated than you would think, mostly due to the error-correction. You can imagine that if you scan a QR code in not ideal conditions, then the camera may misread one or two pixels. This means we need error correction, which is really complex! The code is on my Github .","title":"Overview"},{"location":"programming/qr_code_generator/#what-it-does","text":"It takes a line of text as input from the user, then generates the QR code, saves it as a temporary file and opens it in your default image viewer. From there you can save it somewhere else or share it.","title":"What It Does"},{"location":"programming/qr_code_generator/#technical-summary","text":"It is made of almost 700 lines of Python code split over 9 files. I have used no external modules relating to QR codes, only pillow for graphics, copy to duplicate it and tempfile to save the image. It generates a v5 error level Q alphanumeric QR code, which can hold 87 characters.","title":"Technical Summary"},{"location":"programming/qr_code_generator/#steps","text":"There are multiple steps in making a QR code: Encode the text in a particular text encoding (ISO 8859-1) Generate error correction codewords Interleave the data and error codewords to make a final binary string Place the individual bits of the binary string in the correct places Apply the mask that makes the QR code easier to read Add constant elements (e.g. the corners) Render","title":"Steps"},{"location":"programming/qr_code_generator/#encoding","text":"This is one of the simplest steps, as all you have to do is connect the mode string (0100 for text) to the length of the string in binary. You then have to convert each character in the text to the ISO 8859-1 standard. This is easier than I thought it was going to be as it is the standard that Python's chr() function uses. After that, you just need to fill out the rest of the space with a repeating pattern.","title":"Encoding"},{"location":"programming/qr_code_generator/#error-correction","text":"This is by far the hardest part of the QR code. It has quite a lot of maths involved, including polynomial long division in a Galois Field 256. You have to convert the data string to a message polynomial and get a generator polynomial. You then have to divide the message polynomial by the generator polynomial, and the coefficients of the remainder polynomial are the error correction codewords.","title":"Error Correction"},{"location":"programming/qr_code_generator/#structuring","text":"You have to break the data codewords into blocks, then interleave the first codeword from the first block, followed by the first from the second block and so on. Once you have done the first codeword from each block, you then move onto the second from each block. Once you have done all the data, you then do the same with the error correction codewords. You then need to add a certain number of zeroes to the end so the QR code will be full.","title":"Structuring"},{"location":"programming/qr_code_generator/#placement","text":"This is a relatively simple part, although still more complex than you would imagine as there are a number of pixels that you have to avoid. You just start at the bottom-right of the QR code and work your way up in a zig-zag pattern, avoiding all of the reserved areas.","title":"Placement"},{"location":"programming/qr_code_generator/#masks","text":"Occasionally, when you make a QR code, there will be areas of data that look like special symbols such as the corner patterns. This would really confuse the scanner, so you have to apply a mask. These are just lists of which pixels to invert. You have to apply all of them and evaluate which is the best (i.e. has the fewest confusing patterns) then apply that one.","title":"Masks"},{"location":"programming/qr_code_generator/#constants","text":"This is the simplest bit as most of it is pre-set. You have to add the corners, borders, alignment patterns, timing patterns, dark module and the format information areas. The format information needs to be generated but isn't hard. The format string is mostly the same for my codes as I have only one type of QR code. The only bit that changes is the mask pattern used. You then have to error-correct it and add it.","title":"Constants"},{"location":"programming/qr_code_generator/#render","text":"For this, I use Python's pillow library to work with images. Each pixel of the QR code is 10 pixels wide in the image so when I open it in an image viewer, it doesn't blur the edges between pixels. I just loop over each pixel in the QR code and place a 10x10 square of whatever colour it is in the image.","title":"Render"},{"location":"programming/qr_code_generator/#challenges","text":"The hardest bit of this was the error correction, as at the time I didn't even know what a polynomial was or how binary worked. I had to write code to do maths with strings in weird number systems. It took me about a week to make 160 lines of code, and another week to test and debug it!","title":"Challenges"},{"location":"programming/scripted_journeys/","text":"Scripted Journeys 2024-2025 - Aged 13-14 Overview Scripted Journeys is a text-based adventure game. I originally got the idea from a programming article which made a similar one, which I then improved on. I added multiple maps, which are defined as a set of XML files so users could add new ones if they want. I also added user settings and a few new features. Finally, the hardest part about the whole project was packaging and publishing it so people can actually play it. Links GitHub : https://github.com/SamBell2/ScriptedJourneys Flathub : https://flathub.org/en/apps/io.github.MrPiggy92.ScriptedJourneys Windows Installer : Download How It Works The first thing it does when you open the game is it checks if you have already played it. If this is the first time you play it, it will give you an introduction and the option to change some settings. It then opens the main screen. Once you have chosen a map from the main screen, it launches the actual game. Main Screen This is a simple loop, getting input then using a large if-elif-else block to process it. It supports a few different functions: Listing available maps : It just uses os.listdir() with the map folder and filters the output. Changing settings : It gets user settings from a JSON file, then lets the user select which setting to change and what to change it to, before writing it back to the file. Loading a saved game : It has a single save file, which it loads and decodes using pickle . It is a Python list of the Map object then the Player object. Each of these contain references to the other required objects. Once these are decoded, it starts playing using this current state. Quitting : It simply raises a SystemExit() to close the game. It is terminal-based and all files are closed as soon as they have been written to or read from, so it doesn't need to worry about closing anything special. Launching the game : The main screen doesn't need to do anything apart from run a single function. This runs the actual game, and once it is finished the function returns. Game Loop This is similar to the main screen in that it is just a big loop, but it has a few extra tricks. This is what it does every loop: It checks if you are dead. It outputs a block of information, including what room you are in, where the exits are, the items in the room and what enemies you can fight. It gets your command. It parses and runs your command: It uses a large dictionary that relates the command with the function that runs it and the number of arguments the function takes. It uses fuzzy matching to find which command you meant to type. This means it doesn't matter if you have a typo. It uses a Levenshtein Distance algorithm to work out how many alterations are needed to convert your command into a possible command, and uses the result. It retrieves the correct details about your command from the dictionary. It runs the function with the map and the player as arguments, as well as the second word of the command if the function wants it. If there is a RuntimeError (which I am using as a quit signal) then it breaks out of the loop. I should probably create a separate exception instead of RuntimeError but so far it hasn't been necessary. Publishing Once I had got the game to a playable state, I decided to publish it online. First, I put it on Flathub because I use Linux on my computer, and Flathub is one of the main app stores. Once I had done that, I kept developing it for a while, before I decided to make it work on Windows. I still want to make it work on macOS, but in order to publish apps for Apple, you have to have a Mac and I don't. Flathub This was the most challenging part of the project. First, I had to make the app set itself up when you first run it, then I had to make a manifest file. This defined all of the dependencies my app needed, the metadata, where the code was and how to put all the bits of the app in the right places. I then had to test it a lot because I got half of it wrong the first time. Next, I had to submit a pull request to a GitHub repository which added my manifest and code to a new branch. It got rejected a few times, but I eventually discovered that it was because I had to have the code online, not in the PR. It took me about a week to fix the sources section of the manifest to work with a GitHub source, but once I did it got accepted quickly. It is now online here . Windows The hardest part about packaging for Windows was the refactoring of a good portion of it to remove Linux-only sections, which took a good few weeks. I then had to check that I hadn't broken the Flathub elements, then I spent a while fixing those bits I did break. Once all of the code worked on both of them, I had to compile it to an executable, which contained the actual game. However, I still wasn't finished. This ran the game, but it didn't install it, so i still had to work out how to actually package it. This bit was much easier than I thought, as I found a tool called Inno Setup which did most of the work for me. I still had to configure it so it put all of the files in the right place in the EXE, but it did the hardest bits. You can grab the installer here . Challenges The only real challenge in the programming part was working out how to get the game files over multiple operating systems, but it wasn't too hard. The hardest part was publishing it to Flathub, because I had to make the manifest and then go through the long and complicated process of getting my app accepted by the maintainers. What I Learnt ANSI color codes in terminal output Data and settings storage for apps Python compilation and packaging Cross-platform distribution (Windows & Linux) Creating Windows installers Publishing apps on Flathub","title":"Scripted Journeys"},{"location":"programming/scripted_journeys/#scripted-journeys","text":"2024-2025 - Aged 13-14","title":"Scripted Journeys"},{"location":"programming/scripted_journeys/#overview","text":"Scripted Journeys is a text-based adventure game. I originally got the idea from a programming article which made a similar one, which I then improved on. I added multiple maps, which are defined as a set of XML files so users could add new ones if they want. I also added user settings and a few new features. Finally, the hardest part about the whole project was packaging and publishing it so people can actually play it.","title":"Overview"},{"location":"programming/scripted_journeys/#links","text":"GitHub : https://github.com/SamBell2/ScriptedJourneys Flathub : https://flathub.org/en/apps/io.github.MrPiggy92.ScriptedJourneys Windows Installer : Download","title":"Links"},{"location":"programming/scripted_journeys/#how-it-works","text":"The first thing it does when you open the game is it checks if you have already played it. If this is the first time you play it, it will give you an introduction and the option to change some settings. It then opens the main screen. Once you have chosen a map from the main screen, it launches the actual game.","title":"How It Works"},{"location":"programming/scripted_journeys/#main-screen","text":"This is a simple loop, getting input then using a large if-elif-else block to process it. It supports a few different functions: Listing available maps : It just uses os.listdir() with the map folder and filters the output. Changing settings : It gets user settings from a JSON file, then lets the user select which setting to change and what to change it to, before writing it back to the file. Loading a saved game : It has a single save file, which it loads and decodes using pickle . It is a Python list of the Map object then the Player object. Each of these contain references to the other required objects. Once these are decoded, it starts playing using this current state. Quitting : It simply raises a SystemExit() to close the game. It is terminal-based and all files are closed as soon as they have been written to or read from, so it doesn't need to worry about closing anything special. Launching the game : The main screen doesn't need to do anything apart from run a single function. This runs the actual game, and once it is finished the function returns.","title":"Main Screen"},{"location":"programming/scripted_journeys/#game-loop","text":"This is similar to the main screen in that it is just a big loop, but it has a few extra tricks. This is what it does every loop: It checks if you are dead. It outputs a block of information, including what room you are in, where the exits are, the items in the room and what enemies you can fight. It gets your command. It parses and runs your command: It uses a large dictionary that relates the command with the function that runs it and the number of arguments the function takes. It uses fuzzy matching to find which command you meant to type. This means it doesn't matter if you have a typo. It uses a Levenshtein Distance algorithm to work out how many alterations are needed to convert your command into a possible command, and uses the result. It retrieves the correct details about your command from the dictionary. It runs the function with the map and the player as arguments, as well as the second word of the command if the function wants it. If there is a RuntimeError (which I am using as a quit signal) then it breaks out of the loop. I should probably create a separate exception instead of RuntimeError but so far it hasn't been necessary.","title":"Game Loop"},{"location":"programming/scripted_journeys/#publishing","text":"Once I had got the game to a playable state, I decided to publish it online. First, I put it on Flathub because I use Linux on my computer, and Flathub is one of the main app stores. Once I had done that, I kept developing it for a while, before I decided to make it work on Windows. I still want to make it work on macOS, but in order to publish apps for Apple, you have to have a Mac and I don't.","title":"Publishing"},{"location":"programming/scripted_journeys/#flathub","text":"This was the most challenging part of the project. First, I had to make the app set itself up when you first run it, then I had to make a manifest file. This defined all of the dependencies my app needed, the metadata, where the code was and how to put all the bits of the app in the right places. I then had to test it a lot because I got half of it wrong the first time. Next, I had to submit a pull request to a GitHub repository which added my manifest and code to a new branch. It got rejected a few times, but I eventually discovered that it was because I had to have the code online, not in the PR. It took me about a week to fix the sources section of the manifest to work with a GitHub source, but once I did it got accepted quickly. It is now online here .","title":"Flathub"},{"location":"programming/scripted_journeys/#windows","text":"The hardest part about packaging for Windows was the refactoring of a good portion of it to remove Linux-only sections, which took a good few weeks. I then had to check that I hadn't broken the Flathub elements, then I spent a while fixing those bits I did break. Once all of the code worked on both of them, I had to compile it to an executable, which contained the actual game. However, I still wasn't finished. This ran the game, but it didn't install it, so i still had to work out how to actually package it. This bit was much easier than I thought, as I found a tool called Inno Setup which did most of the work for me. I still had to configure it so it put all of the files in the right place in the EXE, but it did the hardest bits. You can grab the installer here .","title":"Windows"},{"location":"programming/scripted_journeys/#challenges","text":"The only real challenge in the programming part was working out how to get the game files over multiple operating systems, but it wasn't too hard. The hardest part was publishing it to Flathub, because I had to make the manifest and then go through the long and complicated process of getting my app accepted by the maintainers.","title":"Challenges"},{"location":"programming/scripted_journeys/#what-i-learnt","text":"ANSI color codes in terminal output Data and settings storage for apps Python compilation and packaging Cross-platform distribution (Windows & Linux) Creating Windows installers Publishing apps on Flathub","title":"What I Learnt"},{"location":"programming/sudoku_solver/","text":"Sudoku Solver 2023 - Aged 12 Overview This was my first project related to computer intelligence: it uses a recursive backtracking algorithm to test every possible solution, rejecting wrong answers as early as possible. You can give it a partial 9x9 sudoku puzzle and it will solve it for you. I learnt a lot about how recursion can be used to solve search-based problems. Features Solves 9x9 sudoku puzzles Checks for impossible sudoku GUI for easy use Gives hints to the next square Backtracking Algorithm The solver uses a recursive backtracking algorithm to find the solution. The program begins at the first empty square, setting it to 1. It then checks if the puzzle is impossible (i.e. the same number is found twice in a single row, column or 3x3 box). If the puzzle is possible, the solver then calls itself to solve this new puzzle. If, however, the new puzzle is not possible, it changes the 1 to a 2 and checks again. This repeats until either it finds a possible number or gets to 9. If it gets to a 9, then some previous square is wrong, so it blanks the square out and returns to the solver above it. The solver above it now knows that the numbers it has are not possible, so it adds 1 to the last number and tries again. This whole recursive process keeps going until either the whole puzzle is complete, or it has tried every combination and none of them work. If this is the case, it reports an unsolvable sudoku. The Possibility Checker This loops over each square of the puzzle, where it checks if it is empty. If not, if it is in the set of numbers in this row, then it says it is impossible (the same number cannot occur twice in the same row). If it is not in the set, then it is added to the set. It then does the same with columns, and then blocks. The GUI I used Tkinter to make the GUI as it is quite simple. First, I made a Frame containing 81 Entry s in a grid layout. The variables holding these Entries were held in a 2D array mirroring the puzzle. I also added a Progressbar and 3 Button s in another Frame . When you press the Clear button, it empties the entire sudoku. When you press the Hint button, it solves the entire puzzle and tells you the next number. When you press Solve, it solves the puzzle, keeping track of the number of iterations and recursions done, then runs the progress bar for a few seconds (it is relative to the number of steps done) before telling you the result. I didn't need the progress bar, and the entire puzzle is done before the progress bar even starts, but I added it to learn more about GUI elements. The Code You can see the full implementation below, including the solver, validity checking and the GUI. Show/Hide Code #!/usr/bin/env python3 ## IMPORTS ## import tkinter as tk from tkinter import ttk from tkinter.messagebox import showinfo ## VARIABLES ## count = 0 ## METHODS ## def board_to_list(board): entryboard = [[] for _ in range(9)] for row in range(9): for item in range(9): try: if (board[row][item].get() == \"\"): entryboard[row].append(-1) elif not(int(board[row][item].get()) in range(1,10)): raise ValueError else: entryboard[row].append(int(board[row][item].get())) except: showinfo(message=\"Invalid sudoku\") return False return entryboard def find_next_empty(puzzle): for row in range(9): for column in range(9): if puzzle[row][column] == -1: return row, column return None, None def is_valid(puzzle, guess, row, col): row_vals = puzzle[row] if guess in row_vals: return False col_vals = [puzzle[i][col] for i in range(9)] if guess in col_vals: return False row_start = (row // 3) * 3 col_start = (col // 3) * 3 for r in range(row_start, row_start + 3): for c in range(col_start, col_start + 3): if puzzle[r][c] == guess: return False return True def solve_sudoku(puzzle): global count row, col = find_next_empty(puzzle) if row is None and col is None: return True for guess in range(1,10): count += 1 if is_valid(puzzle, guess, row, col): puzzle[row][col] = guess if solve_sudoku(puzzle): return True puzzle[row][col] = -1 return False def is_possible(puzzle): for i in range(9): row = {} column = {} block = {} row_cube = 3 * (i//3) column_cube = 3 * (i%3) for j in range(9): if puzzle[i][j] != -1 and puzzle[i][j] in row: return False row[puzzle[i][j]] = 1 print(row) if puzzle[j][i] != -1 and puzzle[j][i] in column: return False column[puzzle[j][i]] = 1 rc= row_cube + j // 3 cc = column_cube + j % 3 if puzzle[rc][cc] in block and puzzle[rc][cc] != -1: return False block[puzzle[rc][cc]] = 1 return True def handle_solve_click(event, board, pb): global count count = 0 entryboard = board_to_list(board) if not entryboard: return if not(is_possible(entryboard)): showinfo(message=\"Invalid sudoku\") return False solve_sudoku(entryboard) time = count / 5 while time > 10000: time -= 1000 print(time) pb.start(round(time/100)) window.after(round(time), lambda: show_solution(entryboard, board, pb)) window.after(10, update_progress_bar) def show_solution(entryboard, board, pb): global count count = 0 for row in range(9): for item in range(9): board[row][item].delete(0, tk.END) board[row][item].insert(0, entryboard[row][item]) print(\"+\" + \"---+\"*9) for i, row in enumerate(entryboard): print((\"|\" + \" {} {} {} |\"*3).format(*[x if x != -1 else \" \" for x in row])) if i % 3 == 2: print(\"+\" + \"---+\"*9) else: print(\"+\" + \" +\"*9) pb.stop() pb['value'] = 100 def handle_clear_click(event, board, pb, progress): for row in range(9): for item in range(9): board[row][item].delete(0, tk.END) pb['value'] = 0 progress['text'] = \"0.0%\" def handle_hint_click(event, board): entryboard = board_to_list(board) otherboard = board_to_list(board) if not(entryboard): return False if not(is_possible(entryboard)): showinfo(message=\"possible\") return False solve_sudoku(entryboard) for row in range(9): for item in range(9): if otherboard[row][item] != entryboard[row][item]: board[row][item].delete(0, tk.END) board[row][item].insert(0, entryboard[row][item]) return True showinfo(message=\"Already solved\") def update_progress_bar(): if pb['value'] < 100: progress['text'] = f\"{pb['value']}%\" window.after(10, update_progress_bar) else: pb['value'] = 100 progress['text'] = \"Complete\" ## MAIN LOOP ## if __name__ == \"__main__\": window = tk.Tk() board = [[] for _ in range(9)] sudoku_frame = tk.Frame(relief=tk.SUNKEN, borderwidth=5) for row in range(9): for item in range(9): myentry = tk.Entry(master=sudoku_frame, width=2, justify='center') myentry.grid(row=row, column=item) board[row].append(myentry) sudoku_frame.pack() progress_frame = tk.Frame() pb = ttk.Progressbar(master=progress_frame, orient='horizontal', mode='determinate', length=280) pb.grid(row=0, column=0) progress = tk.Label(master=progress_frame, text=\"0.0%\") progress.grid(row=1, column=0) progress_frame.pack(pady=15) button_frame = tk.Frame(relief=tk.RIDGE, borderwidth=5) solve_btn = tk.Button(master=button_frame, text=\"Solve\", relief=tk.FLAT, borderwidth=2) solve_btn.bind(\"<Button-1>\", lambda event: handle_solve_click(event, board, pb)) solve_btn.grid(row=0,column=0) clear_btn = tk.Button(master=button_frame, text=\"Clear\", relief=tk.FLAT, borderwidth=2) clear_btn.bind(\"<Button-1>\", lambda event: handle_clear_click(event, board, pb, progress)) clear_btn.grid(row=0, column=1) hint_btn = tk.Button(master=button_frame, text=\"Hint\", relief=tk.FLAT, borderwidth=2) hint_btn.bind(\"<Button-1>\", lambda event: handle_hint_click(event, board)) hint_btn.grid(row=0, column=3) button_frame.pack() window.mainloop() Challenges The most challenging part of the whole process was actually checking if a solution was impossible. This was mostly because the 3x3 blocks were really hard to check through neatly, without hardcoding a check for each square. If I come back to this project in the future, I will probably remove the progress bar and instead update the grid as it is solved, showing the user exactly how it works. However, this would mean either making the solver directly access frontend code, or restructuring it to yield intermediate states. What I Learned How recursive backtracking works to explore every option How to reject invalid solutions early How to separate backend logic from frontend displays How to make simple GUIs","title":"Sudoku Solver"},{"location":"programming/sudoku_solver/#sudoku-solver","text":"2023 - Aged 12","title":"Sudoku Solver"},{"location":"programming/sudoku_solver/#overview","text":"This was my first project related to computer intelligence: it uses a recursive backtracking algorithm to test every possible solution, rejecting wrong answers as early as possible. You can give it a partial 9x9 sudoku puzzle and it will solve it for you. I learnt a lot about how recursion can be used to solve search-based problems.","title":"Overview"},{"location":"programming/sudoku_solver/#features","text":"Solves 9x9 sudoku puzzles Checks for impossible sudoku GUI for easy use Gives hints to the next square","title":"Features"},{"location":"programming/sudoku_solver/#backtracking-algorithm","text":"The solver uses a recursive backtracking algorithm to find the solution. The program begins at the first empty square, setting it to 1. It then checks if the puzzle is impossible (i.e. the same number is found twice in a single row, column or 3x3 box). If the puzzle is possible, the solver then calls itself to solve this new puzzle. If, however, the new puzzle is not possible, it changes the 1 to a 2 and checks again. This repeats until either it finds a possible number or gets to 9. If it gets to a 9, then some previous square is wrong, so it blanks the square out and returns to the solver above it. The solver above it now knows that the numbers it has are not possible, so it adds 1 to the last number and tries again. This whole recursive process keeps going until either the whole puzzle is complete, or it has tried every combination and none of them work. If this is the case, it reports an unsolvable sudoku.","title":"Backtracking Algorithm"},{"location":"programming/sudoku_solver/#the-possibility-checker","text":"This loops over each square of the puzzle, where it checks if it is empty. If not, if it is in the set of numbers in this row, then it says it is impossible (the same number cannot occur twice in the same row). If it is not in the set, then it is added to the set. It then does the same with columns, and then blocks.","title":"The Possibility Checker"},{"location":"programming/sudoku_solver/#the-gui","text":"I used Tkinter to make the GUI as it is quite simple. First, I made a Frame containing 81 Entry s in a grid layout. The variables holding these Entries were held in a 2D array mirroring the puzzle. I also added a Progressbar and 3 Button s in another Frame . When you press the Clear button, it empties the entire sudoku. When you press the Hint button, it solves the entire puzzle and tells you the next number. When you press Solve, it solves the puzzle, keeping track of the number of iterations and recursions done, then runs the progress bar for a few seconds (it is relative to the number of steps done) before telling you the result. I didn't need the progress bar, and the entire puzzle is done before the progress bar even starts, but I added it to learn more about GUI elements.","title":"The GUI"},{"location":"programming/sudoku_solver/#the-code","text":"You can see the full implementation below, including the solver, validity checking and the GUI. Show/Hide Code #!/usr/bin/env python3 ## IMPORTS ## import tkinter as tk from tkinter import ttk from tkinter.messagebox import showinfo ## VARIABLES ## count = 0 ## METHODS ## def board_to_list(board): entryboard = [[] for _ in range(9)] for row in range(9): for item in range(9): try: if (board[row][item].get() == \"\"): entryboard[row].append(-1) elif not(int(board[row][item].get()) in range(1,10)): raise ValueError else: entryboard[row].append(int(board[row][item].get())) except: showinfo(message=\"Invalid sudoku\") return False return entryboard def find_next_empty(puzzle): for row in range(9): for column in range(9): if puzzle[row][column] == -1: return row, column return None, None def is_valid(puzzle, guess, row, col): row_vals = puzzle[row] if guess in row_vals: return False col_vals = [puzzle[i][col] for i in range(9)] if guess in col_vals: return False row_start = (row // 3) * 3 col_start = (col // 3) * 3 for r in range(row_start, row_start + 3): for c in range(col_start, col_start + 3): if puzzle[r][c] == guess: return False return True def solve_sudoku(puzzle): global count row, col = find_next_empty(puzzle) if row is None and col is None: return True for guess in range(1,10): count += 1 if is_valid(puzzle, guess, row, col): puzzle[row][col] = guess if solve_sudoku(puzzle): return True puzzle[row][col] = -1 return False def is_possible(puzzle): for i in range(9): row = {} column = {} block = {} row_cube = 3 * (i//3) column_cube = 3 * (i%3) for j in range(9): if puzzle[i][j] != -1 and puzzle[i][j] in row: return False row[puzzle[i][j]] = 1 print(row) if puzzle[j][i] != -1 and puzzle[j][i] in column: return False column[puzzle[j][i]] = 1 rc= row_cube + j // 3 cc = column_cube + j % 3 if puzzle[rc][cc] in block and puzzle[rc][cc] != -1: return False block[puzzle[rc][cc]] = 1 return True def handle_solve_click(event, board, pb): global count count = 0 entryboard = board_to_list(board) if not entryboard: return if not(is_possible(entryboard)): showinfo(message=\"Invalid sudoku\") return False solve_sudoku(entryboard) time = count / 5 while time > 10000: time -= 1000 print(time) pb.start(round(time/100)) window.after(round(time), lambda: show_solution(entryboard, board, pb)) window.after(10, update_progress_bar) def show_solution(entryboard, board, pb): global count count = 0 for row in range(9): for item in range(9): board[row][item].delete(0, tk.END) board[row][item].insert(0, entryboard[row][item]) print(\"+\" + \"---+\"*9) for i, row in enumerate(entryboard): print((\"|\" + \" {} {} {} |\"*3).format(*[x if x != -1 else \" \" for x in row])) if i % 3 == 2: print(\"+\" + \"---+\"*9) else: print(\"+\" + \" +\"*9) pb.stop() pb['value'] = 100 def handle_clear_click(event, board, pb, progress): for row in range(9): for item in range(9): board[row][item].delete(0, tk.END) pb['value'] = 0 progress['text'] = \"0.0%\" def handle_hint_click(event, board): entryboard = board_to_list(board) otherboard = board_to_list(board) if not(entryboard): return False if not(is_possible(entryboard)): showinfo(message=\"possible\") return False solve_sudoku(entryboard) for row in range(9): for item in range(9): if otherboard[row][item] != entryboard[row][item]: board[row][item].delete(0, tk.END) board[row][item].insert(0, entryboard[row][item]) return True showinfo(message=\"Already solved\") def update_progress_bar(): if pb['value'] < 100: progress['text'] = f\"{pb['value']}%\" window.after(10, update_progress_bar) else: pb['value'] = 100 progress['text'] = \"Complete\" ## MAIN LOOP ## if __name__ == \"__main__\": window = tk.Tk() board = [[] for _ in range(9)] sudoku_frame = tk.Frame(relief=tk.SUNKEN, borderwidth=5) for row in range(9): for item in range(9): myentry = tk.Entry(master=sudoku_frame, width=2, justify='center') myentry.grid(row=row, column=item) board[row].append(myentry) sudoku_frame.pack() progress_frame = tk.Frame() pb = ttk.Progressbar(master=progress_frame, orient='horizontal', mode='determinate', length=280) pb.grid(row=0, column=0) progress = tk.Label(master=progress_frame, text=\"0.0%\") progress.grid(row=1, column=0) progress_frame.pack(pady=15) button_frame = tk.Frame(relief=tk.RIDGE, borderwidth=5) solve_btn = tk.Button(master=button_frame, text=\"Solve\", relief=tk.FLAT, borderwidth=2) solve_btn.bind(\"<Button-1>\", lambda event: handle_solve_click(event, board, pb)) solve_btn.grid(row=0,column=0) clear_btn = tk.Button(master=button_frame, text=\"Clear\", relief=tk.FLAT, borderwidth=2) clear_btn.bind(\"<Button-1>\", lambda event: handle_clear_click(event, board, pb, progress)) clear_btn.grid(row=0, column=1) hint_btn = tk.Button(master=button_frame, text=\"Hint\", relief=tk.FLAT, borderwidth=2) hint_btn.bind(\"<Button-1>\", lambda event: handle_hint_click(event, board)) hint_btn.grid(row=0, column=3) button_frame.pack() window.mainloop()","title":"The Code"},{"location":"programming/sudoku_solver/#challenges","text":"The most challenging part of the whole process was actually checking if a solution was impossible. This was mostly because the 3x3 blocks were really hard to check through neatly, without hardcoding a check for each square. If I come back to this project in the future, I will probably remove the progress bar and instead update the grid as it is solved, showing the user exactly how it works. However, this would mean either making the solver directly access frontend code, or restructuring it to yield intermediate states.","title":"Challenges"},{"location":"programming/sudoku_solver/#what-i-learned","text":"How recursive backtracking works to explore every option How to reject invalid solutions early How to separate backend logic from frontend displays How to make simple GUIs","title":"What I Learned"},{"location":"robotics/WER2025/","text":"World Educational Robotics 2025 2025 - Aged 14 Me testing my robot on one of the tasks Overview WER is an international educational robotics curriculum. There are many countries that host WER extra-curricular clubs with millions of participants, and some countries host robotics competitions. The most regular competitions take place in Britain every July and the winners from that competition qualify for the world championships in December in Shanghai. It is a large event, with over 6000 contestants in the championships (at least before Covid - there are fewer now). I joined in late December last year, and I went to the competition in England. I came 4th in my age category, but the top 3 all came from China to compete, so I qualified as the top British contestant and went to the world championships in Shanghai. The championships were on the 13th of December. It was a very stressful day, but in the end I got 3rd place! About the competition Each year, the competition has a different theme and map. This year was autonomous driving, and had pre-set tasks relating to the theme, e.g. Replacing the batteries in a model electric car and picking up containers to transport. You must compete in teams of 1 - 3. You get given a basic robot (plastic plate, 2 motors with wheels, 5 line sensors and a controller) and must build additional things to complete the required tasks. It uses Abilix robots which have a meccano-style construction. You must also program the robot using either a version of Scratch or Python to move around the map and complete the required tasks. This Year's Setup The map was 120cm x 220cm, and it had a start box, 10 different positions and a parking space. The different ways of getting points were as follows: Departure 20pts : Leave the start box at least once. Task 1 50pts : Spin a bar around a certain number of times. Task 2 90pts : 10pts x 3 : Remove 3 different coloured plastic blocks from a stand. 10pts x 3 : Take all 3 blocks back to the start box. 30pts : Keep the blocks in the same order as they were on the stand. Task 3 60pts : 30pts : Spin a bar around to drop a red block on the ground. 30pts : Catch the red block and take it back to the start box. Task 4 160pts : This is a model of an electric car. It has a model of a dead battery in the bottom and a model of a charged battery in the top. 30pts : Remove the dead battery from the car. 30pts : Remove the charged battery from the car. 30pts : Take the dead battery back to the start box. 30pts : Take the charged battery back to the start box. 40pts : Put the charged battery back where the dead battery was. Parking 60pts : 30pts : End the run with at least 1 wheel in the parking space. 30pts : Have the red block from Task 3 in the parking space at the end of your run. Bonus points Up to 40pts : You get 40 bonus points. Each time you have to pick the robot up outside the start box, you lose 10 of these bonus points, until you have none left. Field tasks 100pts x 3 : There are 3 unseen tasks that first appear at the competition. Each one is worth 100pts. Each of the tasks could be in any position. In case you're interested, the full rules are here and this was the map: Saturday Classes I go to a club every Saturday for an hour and a half. This is where I do most of my progress, testing, and learning. Here I get to use one of the club's robots. Before I went to the competition, about half of these sessions were learning things such as calibration curves and how to line up neatly with the tasks, and the other half were just preparing for the competition. Since the British competition, I have needed all the time I can get to train and practise, but now that the championships are over, I can relax again. British Competition When I got to the competiton, I saw where the tasks were on the map and what the 2 new tasks were. I had 2 hours to get the robot to do all of the pre-set tasks in their locations and engineer solutions to the new tasks. Then we had a 3-minute judging session, lunch, and in the afternoon all of the tasks had been moved around. We had another 2 hours to prepare the robots and code for the new positions, then a 3 minute judging and the awards ceremony. I am being presented my award Home programing As well as preparing my code at the Saturday classes, I also do some at home. The main bit that I did was a few months ago where I wrote all of the code to get to all of the positions and back in a single week, then on Saturday I tested it and most of it worked or almost worked first time! It only took me about 2 hours of debugging to get all of it working. I have also done other programming and preparing at home, sych as thinking of a few different methods for task 4. Ultimately, I didn't actually use any of those methods, as I saw some other really good designs at the competition which I have taken inspiration from. World Championship Shortly after we arrived at the venue, we saw the 3 new tasks: You had to lift a bar entirely off a stand and drop it on the floor. I can't remember what this one was, but it was between the other 2 in regards to difficulty You had to lift a small plastic box up and place it on a higher platform. In the opening ceremony, I had to read out the competitors oath (essentially saying that we won't cheat) in English. However, while I was waiting to go up on the stage, most other teams started writing code, testing and debugging early, so I lost about 40 minutes of preparation time compared to the other teams. I then managed to test everything, but I realised that I had built my solution to task 4 the wrong way round! My code to go to the parking space also stopped working. In the end, I managed to get 350 points in the morning, which was the highest of the entire British division. In the afternoon, I managed to do a bit more. I solved the first of the additional tasks, and got the red block to the parking space (although neither of my wheels were actually in the box). I think I got 440 points. It was then the awards and closing ceremony. I came 3rd! I was aiming for top 50, so I was shocked when they read my name out! My Code I have around 320 lines of Python code, organised into 5 sections. The first section is the main function. This is what I change the most often. After that, I have the code to complete each task once in position. Next, I have utility functions, such as calibrating the sensors and leaving the start box. Section 4 contains the functions to take me to each position. Many of these have small speed optimizations, such as skipping lines instead of going round the longer way. Finally, I have the code to take the robot back to the start box from each position. You can see the code here (it isn't the most efficient, but it works well enough): Show/Hide Code # IMPORTS import robot # MAIN def main(): start() park() # UTILITY def start(): robot.WER_InitRobot(1,-1,2,1,1) robot.WER_SetMotor_T(30,30,1) def setup(): robot.WER_InitRobot(1,-1,2,1,1) robot.WER_Set_GrayscaleSensor() def sideways(): robot.WER_SetMotor_T(-30,-30,1) robot.WER_SetMotor_E(30,-30, 2, 2200) robot.WER_SetMotor_T(30,30,2) robot.WER_SetMotor_E(-30,30, 1, 2200) robot.WER_SetMotor_T(30,30,2.1) robot.WER_SetMotor_E(-30,30, 1, 2200) robot.WER_SetMotor_T(30,30,2.3) def park(): robot.WER_SetMotor_T(30, -30, 0.5) robot. WER_SetMotor_T(100, 100, 2.7) # TASKS def t1(): robot.set_motor(3, -30) robot.sleep(1.2) robot.set_motor(3, 0) def t2(): robot.set_motor(3, 30) robot.sleep(1) robot.set_motor(3,10) robot.WER_SetMotor_T(-30, -30, 0.5) robot.set_motor(3, 0) robot.WER_SetMotor_T(-10, -10, 0.3) def t3(): robot.set_motor(3, 60) robot.sleep(1.5) robot.set_motor(3, 0) def t4a(): robot.set_motor(3, 10) while robot.get_encoder(3) < 1100: pass robot.set_motor(3,0) robot.set_motor(4,-30) robot.sleep(1) robot.set_motor(4,0) def t4b(): robot.set_motor(3,-10) while robot.get_encoder(3) > -1100: pass robot.set_motor(3,0) def t5(): robot.set_motor(3,20) robot.sleep(1) robot.set_motor(3,0) def t6(): pass def t7(): pass # POSITIONS def p1(task=None): robot.WER_LineWay_C(40,5,0.3) robot.WER_Around(30,-30,0) robot.WER_LineWay_C(40,15,0.3) robot.WER_Around(-30,30,0) robot.WER_LineWay_C(40,1,0.3) robot.WER_Around(-30, 30,0) robot.WER_LineWay_C(40,5,0.3) robot.WER_Around(30, -30, 0) robot.WER_AdvancedWay_T(30,3) if task != None: task() r1() def p2(task=None): robot.WER_LineWay_C(60,5,0.2) robot.WER_Around(50,-50,0) robot.WER_LineWay_C(60,15,0.2) robot.WER_Around(-50,50,0) robot.WER_LineWay_C(60,1,0.3) robot.WER_AdvancedWay_T(30,1.2) if task != None: task() r2() def p3(task=None): robot.WER_LineWay_C(60,5,0.3) robot.WER_Around(60, -60,0) for _ in range(8): robot.WER_AdvancedWay_T(60,0.1) while robot.get_channel_gray(1,5) < 2000: robot.WER_SetMotor_K(40,40) robot.sleep(0.4) robot.WER_SetMotor_K(0,0) robot.WER_Around(-60, 60,0) robot.WER_LineWay_C(60,1,0.1) robot.WER_Around(-60,60,1) while(robot.get_channel_gray(1, 5) < 2000): robot.WER_SetMotor_K(-60,-60) robot.sleep(0.3) robot.WER_SetMotor_K(0,0) while(robot.get_channel_gray(1, 5) < 2000): robot.WER_SetMotor_K(-60,-60) robot.WER_SetMotor_K(0,0) robot.WER_SetMotor_T(60, 60, 0.2) robot.WER_Around(60, -60, 0) robot.WER_AdvancedWay_T(30,2) if task != None: task() r3() def p4(task=None): robot.WER_LineWay_C(40,5,0.3) robot.WER_Around(30,-30,0) robot.WER_LineWay_C(40,15,0.3) robot.WER_Around(-30,30,0) robot.WER_LineWay_C(40,1,0.3) while(robot.get_channel_gray(1, 5) < 1000): robot.WER_SetMotor_K(-35,35) robot.WER_SetMotor_K(0,0) while(robot.get_channel_gray(1, 3) < 1000): robot.WER_SetMotor_K(-35,35) robot.WER_SetMotor_K(0,0) while(robot.get_channel_gray(1, 5) < 1000): robot.WER_SetMotor_K(-35,-35) robot.sleep(0.3) robot.WER_SetMotor_K(0,0) while(robot.get_channel_gray(1, 5) < 1000): robot.WER_SetMotor_K(-35,-35) robot.sleep(0.3) robot.WER_SetMotor_K(0,0) while(robot.get_channel_gray(1, 5) < 1000): robot.WER_SetMotor_K(-35,-37) robot.WER_SetMotor_K(0,0) robot.WER_SetMotor_T(40, 40, 0.3) robot.WER_Around(30, -30, 0) robot.WER_AdvancedWay_T(30,1.7) if task != None: task() r4() def p5(task=None): robot.WER_LineWay_C(40,5,0.3) robot.WER_Around(30,-30,0) robot.WER_LineWay_C(40,15,0.3) robot.WER_SetMotor_T(40, 40, 0.3) while(robot.get_channel_gray(1, 5) < 2000): robot.WER_SetMotor_K(60,60) robot.sleep(0.3) robot.WER_SetMotor_K(0,0) robot.WER_Around(-30, 30, 0) robot.WER_LineWay_C(40,5,0.3) robot.WER_Around(30,-30,0) robot.WER_AdvancedWay_T(30, 2.2) if task != None: task() r5() def p6(task=None): robot.WER_LineWay_C(60,5,0.2) robot.WER_Around(30,-30,0) robot.WER_LineWay_C(60,15,0.2) robot.WER_Around(30, -30,0) robot.WER_LineWay_C(60,1,0.05) robot.WER_Around(-30, 30, 0) robot.WER_LineWay_C(60,5,0.2) robot.WER_SetMotor_T(30,30,0.2) robot.WER_LineWay_C(60,5,0.3) robot.WER_SetMotor_T(30,30,2.2) if task != None: task() r6() def p7(task=None): robot.WER_LineWay_C(40,5,0.3) robot.WER_Around(30,-30,0) robot.WER_LineWay_C(40,15,0.3) robot.WER_SetMotor_T(40, 40, 0.3) while(robot.get_channel_gray(1, 5) < 2000): robot.WER_SetMotor_K(60,60) robot.sleep(0.3) robot.WER_SetMotor_K(0,0) while robot.get_channel_gray(1,3) < 3000: robot.WER_SetMotor_K(40,-40) robot.WER_AdvancedWay_T(40,1.8) if task != None: task() r7() def p8(task=None): robot.WER_LineWay_C(60,5,0.2) robot.WER_Around(50,-50,0) robot.WER_LineWay_C(60,15,0.2) x = robot.get_encoder(1) print(x) while robot.get_encoder(1) > x-5200: robot.WER_SetMotor_K(60,60) print(robot.get_encoder(1)) robot.WER_SetMotor_K(0,0) robot.WER_Around(60,0,0) robot.WER_Around(60,0,0) robot.WER_AdvancedWay_T(30, 1.2) if task != None: task() r8() def p9(task=None): robot.WER_LineWay_C(40,5,0.3) robot.WER_Around(30,-30,0) robot.WER_LineWay_C(40,15,0.3) robot.WER_Around(30, -30,0) robot.WER_LineWay_C(30,1,0.3) robot.WER_AdvancedWay_T(20, 1.8) if task != None: task() r9() def p10(task=None): robot.WER_LineWay_C(40,5,0.3) robot.WER_Around(30,-30,0) robot.WER_LineWay_C(40,15,0.3) robot.WER_Around(-30,30,0) robot.WER_LineWay_C(40,1,0.3) robot.WER_Around(-30, 30, 0) robot.WER_LineWay_C(40, 5, 0.3) robot.WER_AdvancedWay_T(30,1.2) if task != None: task() r10() # RETURNS def r1(): robot.WER_SetMotor_T(-50, -60, 2.2) def r2(): while(robot.get_channel_gray(1, 1) < 2000): robot.WER_SetMotor_K(-60,-60) robot.sleep(0.2) while(robot.get_channel_gray(1, 1) < 2000): robot.WER_SetMotor_K(-60,-60) robot.WER_SetMotor_K(60, 60) robot.sleep(0.2) robot.WER_SetMotor_K(0,0) robot.WER_Around(-60, 60, 0) robot.WER_LineWay_C(60, 1, 0.2) robot.WER_Around(-60, 60, 0) robot.WER_LineWay_C(60, 15, 0.3) def r3(): while robot.get_channel_gray(1, 5) < 2000: robot.WER_SetMotor_K(-60, -60) robot.WER_SetMotor_T(-60, -60, 0.3) while robot.get_channel_gray(1, 5) < 2000: robot.WER_SetMotor_K(-60, -60) robot.WER_SetMotor_T(60,60,0.3) robot.WER_Around(-60, 60, 0) robot.WER_LineWay_C(60,15,0) robot.WER_SetMotor_T(60, 60, 0.3) while robot.get_channel_gray(1, 1) < 2000: robot.WER_SetMotor_K(60, 60) robot.WER_SetMotor_K(0,0) robot.WER_SetMotor_T(-60, 60, 0.4) robot.WER_SetMotor_T(60, 60, 0.3) def r4(): while robot.get_channel_gray(1, 1) < 2000: robot.WER_SetMotor_K(-30, -30) robot.WER_SetMotor_T(-30, -30, 0.3) while robot.get_channel_gray(1, 5) < 2000: robot.WER_SetMotor_K(-30, -30) robot.WER_SetMotor_T(30,30,0.3) robot.WER_Around(-30, 30, 0) robot.WER_LineWay_C(40,15,0) robot.WER_SetMotor_T(30, 30, 0.3) while robot.get_channel_gray(1, 1) < 2000: robot.WER_SetMotor_K(30, 30) robot.WER_SetMotor_K(0,0) robot.WER_SetMotor_T(-30, 30, 0.5) robot.WER_SetMotor_T(30, 30, 0.3) def r5(): robot.WER_SetMotor_T(-54,-50,5.5) def r6(): while robot.get_channel_gray(1,1) < 2000: robot.WER_SetMotor_K(-50,-50) while robot.get_channel_gray(1,1) >= 2000: robot.WER_SetMotor_K(-50,50) while robot.get_channel_gray(1,1) < 2000: robot.WER_SetMotor_K(-50,50) while robot.get_channel_gray(1,3) < 2000: robot.WER_SetMotor_K(-50,50) robot.WER_LineWay_C(60,15,0.3) while robot.get_channel_gray(1,1) < 2000: robot.WER_SetMotor_K(60,60) robot.sleep(0.2) robot.WER_SetMotor_T(-50,50,0.5) robot.WER_SetMotor_T(50,50,0.3) def r7(): while robot.get_channel_gray(1,1) < 2000: robot.WER_SetMotor_K(-40, -40) robot.WER_SetMotor_T(40,40,0.3) robot.WER_Around(40,-40,0) robot.WER_LineWay_C(50, 15,0.3) while robot.get_channel_gray(1,3) < 2000: robot.WER_SetMotor_K(40,40) robot.sleep(0.3) robot.WER_SetMotor_K(0,0) robot.WER_Around(-30,30,0) robot.WER_SetMotor_T(30,30,0.5) def r8(): robot.WER_SetMotor_T(-90,-60,4) def r9(): while robot.get_channel_gray(1, 1) < 2000: robot.WER_SetMotor_K(-30, -30) robot.WER_SetMotor_T(30, -30, 0.5) robot.WER_SetMotor_T(30, 28, 3) def r10(): while robot.get_channel_gray(1,5) < 2000: robot.WER_SetMotor_K(-30, -30) robot.WER_SetMotor_T(-30, 30, 0.3) robot.WER_SetMotor_T(30, 30, 3) # START main()#program entry Challenges Doing this had a lot of challenges, from my first sessions building the robot, starting to program it, learning how to use C++ with the robot, etc. One of the biggest (unexpected) challenges was when they completely changed the syntax of the function calls 3 weeks before the competition! I had to spend a lot of time at home converting my 300 lines of code. Shortly after the competition, they changed from the old C202 robots to the new SK201 robots. This meant that I had to change all of my code from C++ to Python. However, the functions were very similar so it didn't take too long. The most challenging task model was task 4, because the dead battery was too low for a motor to reach, so I had to use a crank linkage with a claw on the end to move it. Also, you had to put the battery back in the low position so the claw had to be able to grab and release.","title":"WER 2025"},{"location":"robotics/WER2025/#world-educational-robotics-2025","text":"2025 - Aged 14 Me testing my robot on one of the tasks","title":"World Educational Robotics 2025"},{"location":"robotics/WER2025/#overview","text":"WER is an international educational robotics curriculum. There are many countries that host WER extra-curricular clubs with millions of participants, and some countries host robotics competitions. The most regular competitions take place in Britain every July and the winners from that competition qualify for the world championships in December in Shanghai. It is a large event, with over 6000 contestants in the championships (at least before Covid - there are fewer now). I joined in late December last year, and I went to the competition in England. I came 4th in my age category, but the top 3 all came from China to compete, so I qualified as the top British contestant and went to the world championships in Shanghai. The championships were on the 13th of December. It was a very stressful day, but in the end I got 3rd place!","title":"Overview"},{"location":"robotics/WER2025/#about-the-competition","text":"Each year, the competition has a different theme and map. This year was autonomous driving, and had pre-set tasks relating to the theme, e.g. Replacing the batteries in a model electric car and picking up containers to transport. You must compete in teams of 1 - 3. You get given a basic robot (plastic plate, 2 motors with wheels, 5 line sensors and a controller) and must build additional things to complete the required tasks. It uses Abilix robots which have a meccano-style construction. You must also program the robot using either a version of Scratch or Python to move around the map and complete the required tasks.","title":"About the competition"},{"location":"robotics/WER2025/#this-years-setup","text":"The map was 120cm x 220cm, and it had a start box, 10 different positions and a parking space. The different ways of getting points were as follows: Departure 20pts : Leave the start box at least once. Task 1 50pts : Spin a bar around a certain number of times. Task 2 90pts : 10pts x 3 : Remove 3 different coloured plastic blocks from a stand. 10pts x 3 : Take all 3 blocks back to the start box. 30pts : Keep the blocks in the same order as they were on the stand. Task 3 60pts : 30pts : Spin a bar around to drop a red block on the ground. 30pts : Catch the red block and take it back to the start box. Task 4 160pts : This is a model of an electric car. It has a model of a dead battery in the bottom and a model of a charged battery in the top. 30pts : Remove the dead battery from the car. 30pts : Remove the charged battery from the car. 30pts : Take the dead battery back to the start box. 30pts : Take the charged battery back to the start box. 40pts : Put the charged battery back where the dead battery was. Parking 60pts : 30pts : End the run with at least 1 wheel in the parking space. 30pts : Have the red block from Task 3 in the parking space at the end of your run. Bonus points Up to 40pts : You get 40 bonus points. Each time you have to pick the robot up outside the start box, you lose 10 of these bonus points, until you have none left. Field tasks 100pts x 3 : There are 3 unseen tasks that first appear at the competition. Each one is worth 100pts. Each of the tasks could be in any position. In case you're interested, the full rules are here and this was the map:","title":"This Year's Setup"},{"location":"robotics/WER2025/#saturday-classes","text":"I go to a club every Saturday for an hour and a half. This is where I do most of my progress, testing, and learning. Here I get to use one of the club's robots. Before I went to the competition, about half of these sessions were learning things such as calibration curves and how to line up neatly with the tasks, and the other half were just preparing for the competition. Since the British competition, I have needed all the time I can get to train and practise, but now that the championships are over, I can relax again.","title":"Saturday Classes"},{"location":"robotics/WER2025/#british-competition","text":"When I got to the competiton, I saw where the tasks were on the map and what the 2 new tasks were. I had 2 hours to get the robot to do all of the pre-set tasks in their locations and engineer solutions to the new tasks. Then we had a 3-minute judging session, lunch, and in the afternoon all of the tasks had been moved around. We had another 2 hours to prepare the robots and code for the new positions, then a 3 minute judging and the awards ceremony. I am being presented my award","title":"British Competition"},{"location":"robotics/WER2025/#home-programing","text":"As well as preparing my code at the Saturday classes, I also do some at home. The main bit that I did was a few months ago where I wrote all of the code to get to all of the positions and back in a single week, then on Saturday I tested it and most of it worked or almost worked first time! It only took me about 2 hours of debugging to get all of it working. I have also done other programming and preparing at home, sych as thinking of a few different methods for task 4. Ultimately, I didn't actually use any of those methods, as I saw some other really good designs at the competition which I have taken inspiration from.","title":"Home programing"},{"location":"robotics/WER2025/#world-championship","text":"Shortly after we arrived at the venue, we saw the 3 new tasks: You had to lift a bar entirely off a stand and drop it on the floor. I can't remember what this one was, but it was between the other 2 in regards to difficulty You had to lift a small plastic box up and place it on a higher platform. In the opening ceremony, I had to read out the competitors oath (essentially saying that we won't cheat) in English. However, while I was waiting to go up on the stage, most other teams started writing code, testing and debugging early, so I lost about 40 minutes of preparation time compared to the other teams. I then managed to test everything, but I realised that I had built my solution to task 4 the wrong way round! My code to go to the parking space also stopped working. In the end, I managed to get 350 points in the morning, which was the highest of the entire British division. In the afternoon, I managed to do a bit more. I solved the first of the additional tasks, and got the red block to the parking space (although neither of my wheels were actually in the box). I think I got 440 points. It was then the awards and closing ceremony. I came 3rd! I was aiming for top 50, so I was shocked when they read my name out!","title":"World Championship"},{"location":"robotics/WER2025/#my-code","text":"I have around 320 lines of Python code, organised into 5 sections. The first section is the main function. This is what I change the most often. After that, I have the code to complete each task once in position. Next, I have utility functions, such as calibrating the sensors and leaving the start box. Section 4 contains the functions to take me to each position. Many of these have small speed optimizations, such as skipping lines instead of going round the longer way. Finally, I have the code to take the robot back to the start box from each position. You can see the code here (it isn't the most efficient, but it works well enough): Show/Hide Code # IMPORTS import robot # MAIN def main(): start() park() # UTILITY def start(): robot.WER_InitRobot(1,-1,2,1,1) robot.WER_SetMotor_T(30,30,1) def setup(): robot.WER_InitRobot(1,-1,2,1,1) robot.WER_Set_GrayscaleSensor() def sideways(): robot.WER_SetMotor_T(-30,-30,1) robot.WER_SetMotor_E(30,-30, 2, 2200) robot.WER_SetMotor_T(30,30,2) robot.WER_SetMotor_E(-30,30, 1, 2200) robot.WER_SetMotor_T(30,30,2.1) robot.WER_SetMotor_E(-30,30, 1, 2200) robot.WER_SetMotor_T(30,30,2.3) def park(): robot.WER_SetMotor_T(30, -30, 0.5) robot. WER_SetMotor_T(100, 100, 2.7) # TASKS def t1(): robot.set_motor(3, -30) robot.sleep(1.2) robot.set_motor(3, 0) def t2(): robot.set_motor(3, 30) robot.sleep(1) robot.set_motor(3,10) robot.WER_SetMotor_T(-30, -30, 0.5) robot.set_motor(3, 0) robot.WER_SetMotor_T(-10, -10, 0.3) def t3(): robot.set_motor(3, 60) robot.sleep(1.5) robot.set_motor(3, 0) def t4a(): robot.set_motor(3, 10) while robot.get_encoder(3) < 1100: pass robot.set_motor(3,0) robot.set_motor(4,-30) robot.sleep(1) robot.set_motor(4,0) def t4b(): robot.set_motor(3,-10) while robot.get_encoder(3) > -1100: pass robot.set_motor(3,0) def t5(): robot.set_motor(3,20) robot.sleep(1) robot.set_motor(3,0) def t6(): pass def t7(): pass # POSITIONS def p1(task=None): robot.WER_LineWay_C(40,5,0.3) robot.WER_Around(30,-30,0) robot.WER_LineWay_C(40,15,0.3) robot.WER_Around(-30,30,0) robot.WER_LineWay_C(40,1,0.3) robot.WER_Around(-30, 30,0) robot.WER_LineWay_C(40,5,0.3) robot.WER_Around(30, -30, 0) robot.WER_AdvancedWay_T(30,3) if task != None: task() r1() def p2(task=None): robot.WER_LineWay_C(60,5,0.2) robot.WER_Around(50,-50,0) robot.WER_LineWay_C(60,15,0.2) robot.WER_Around(-50,50,0) robot.WER_LineWay_C(60,1,0.3) robot.WER_AdvancedWay_T(30,1.2) if task != None: task() r2() def p3(task=None): robot.WER_LineWay_C(60,5,0.3) robot.WER_Around(60, -60,0) for _ in range(8): robot.WER_AdvancedWay_T(60,0.1) while robot.get_channel_gray(1,5) < 2000: robot.WER_SetMotor_K(40,40) robot.sleep(0.4) robot.WER_SetMotor_K(0,0) robot.WER_Around(-60, 60,0) robot.WER_LineWay_C(60,1,0.1) robot.WER_Around(-60,60,1) while(robot.get_channel_gray(1, 5) < 2000): robot.WER_SetMotor_K(-60,-60) robot.sleep(0.3) robot.WER_SetMotor_K(0,0) while(robot.get_channel_gray(1, 5) < 2000): robot.WER_SetMotor_K(-60,-60) robot.WER_SetMotor_K(0,0) robot.WER_SetMotor_T(60, 60, 0.2) robot.WER_Around(60, -60, 0) robot.WER_AdvancedWay_T(30,2) if task != None: task() r3() def p4(task=None): robot.WER_LineWay_C(40,5,0.3) robot.WER_Around(30,-30,0) robot.WER_LineWay_C(40,15,0.3) robot.WER_Around(-30,30,0) robot.WER_LineWay_C(40,1,0.3) while(robot.get_channel_gray(1, 5) < 1000): robot.WER_SetMotor_K(-35,35) robot.WER_SetMotor_K(0,0) while(robot.get_channel_gray(1, 3) < 1000): robot.WER_SetMotor_K(-35,35) robot.WER_SetMotor_K(0,0) while(robot.get_channel_gray(1, 5) < 1000): robot.WER_SetMotor_K(-35,-35) robot.sleep(0.3) robot.WER_SetMotor_K(0,0) while(robot.get_channel_gray(1, 5) < 1000): robot.WER_SetMotor_K(-35,-35) robot.sleep(0.3) robot.WER_SetMotor_K(0,0) while(robot.get_channel_gray(1, 5) < 1000): robot.WER_SetMotor_K(-35,-37) robot.WER_SetMotor_K(0,0) robot.WER_SetMotor_T(40, 40, 0.3) robot.WER_Around(30, -30, 0) robot.WER_AdvancedWay_T(30,1.7) if task != None: task() r4() def p5(task=None): robot.WER_LineWay_C(40,5,0.3) robot.WER_Around(30,-30,0) robot.WER_LineWay_C(40,15,0.3) robot.WER_SetMotor_T(40, 40, 0.3) while(robot.get_channel_gray(1, 5) < 2000): robot.WER_SetMotor_K(60,60) robot.sleep(0.3) robot.WER_SetMotor_K(0,0) robot.WER_Around(-30, 30, 0) robot.WER_LineWay_C(40,5,0.3) robot.WER_Around(30,-30,0) robot.WER_AdvancedWay_T(30, 2.2) if task != None: task() r5() def p6(task=None): robot.WER_LineWay_C(60,5,0.2) robot.WER_Around(30,-30,0) robot.WER_LineWay_C(60,15,0.2) robot.WER_Around(30, -30,0) robot.WER_LineWay_C(60,1,0.05) robot.WER_Around(-30, 30, 0) robot.WER_LineWay_C(60,5,0.2) robot.WER_SetMotor_T(30,30,0.2) robot.WER_LineWay_C(60,5,0.3) robot.WER_SetMotor_T(30,30,2.2) if task != None: task() r6() def p7(task=None): robot.WER_LineWay_C(40,5,0.3) robot.WER_Around(30,-30,0) robot.WER_LineWay_C(40,15,0.3) robot.WER_SetMotor_T(40, 40, 0.3) while(robot.get_channel_gray(1, 5) < 2000): robot.WER_SetMotor_K(60,60) robot.sleep(0.3) robot.WER_SetMotor_K(0,0) while robot.get_channel_gray(1,3) < 3000: robot.WER_SetMotor_K(40,-40) robot.WER_AdvancedWay_T(40,1.8) if task != None: task() r7() def p8(task=None): robot.WER_LineWay_C(60,5,0.2) robot.WER_Around(50,-50,0) robot.WER_LineWay_C(60,15,0.2) x = robot.get_encoder(1) print(x) while robot.get_encoder(1) > x-5200: robot.WER_SetMotor_K(60,60) print(robot.get_encoder(1)) robot.WER_SetMotor_K(0,0) robot.WER_Around(60,0,0) robot.WER_Around(60,0,0) robot.WER_AdvancedWay_T(30, 1.2) if task != None: task() r8() def p9(task=None): robot.WER_LineWay_C(40,5,0.3) robot.WER_Around(30,-30,0) robot.WER_LineWay_C(40,15,0.3) robot.WER_Around(30, -30,0) robot.WER_LineWay_C(30,1,0.3) robot.WER_AdvancedWay_T(20, 1.8) if task != None: task() r9() def p10(task=None): robot.WER_LineWay_C(40,5,0.3) robot.WER_Around(30,-30,0) robot.WER_LineWay_C(40,15,0.3) robot.WER_Around(-30,30,0) robot.WER_LineWay_C(40,1,0.3) robot.WER_Around(-30, 30, 0) robot.WER_LineWay_C(40, 5, 0.3) robot.WER_AdvancedWay_T(30,1.2) if task != None: task() r10() # RETURNS def r1(): robot.WER_SetMotor_T(-50, -60, 2.2) def r2(): while(robot.get_channel_gray(1, 1) < 2000): robot.WER_SetMotor_K(-60,-60) robot.sleep(0.2) while(robot.get_channel_gray(1, 1) < 2000): robot.WER_SetMotor_K(-60,-60) robot.WER_SetMotor_K(60, 60) robot.sleep(0.2) robot.WER_SetMotor_K(0,0) robot.WER_Around(-60, 60, 0) robot.WER_LineWay_C(60, 1, 0.2) robot.WER_Around(-60, 60, 0) robot.WER_LineWay_C(60, 15, 0.3) def r3(): while robot.get_channel_gray(1, 5) < 2000: robot.WER_SetMotor_K(-60, -60) robot.WER_SetMotor_T(-60, -60, 0.3) while robot.get_channel_gray(1, 5) < 2000: robot.WER_SetMotor_K(-60, -60) robot.WER_SetMotor_T(60,60,0.3) robot.WER_Around(-60, 60, 0) robot.WER_LineWay_C(60,15,0) robot.WER_SetMotor_T(60, 60, 0.3) while robot.get_channel_gray(1, 1) < 2000: robot.WER_SetMotor_K(60, 60) robot.WER_SetMotor_K(0,0) robot.WER_SetMotor_T(-60, 60, 0.4) robot.WER_SetMotor_T(60, 60, 0.3) def r4(): while robot.get_channel_gray(1, 1) < 2000: robot.WER_SetMotor_K(-30, -30) robot.WER_SetMotor_T(-30, -30, 0.3) while robot.get_channel_gray(1, 5) < 2000: robot.WER_SetMotor_K(-30, -30) robot.WER_SetMotor_T(30,30,0.3) robot.WER_Around(-30, 30, 0) robot.WER_LineWay_C(40,15,0) robot.WER_SetMotor_T(30, 30, 0.3) while robot.get_channel_gray(1, 1) < 2000: robot.WER_SetMotor_K(30, 30) robot.WER_SetMotor_K(0,0) robot.WER_SetMotor_T(-30, 30, 0.5) robot.WER_SetMotor_T(30, 30, 0.3) def r5(): robot.WER_SetMotor_T(-54,-50,5.5) def r6(): while robot.get_channel_gray(1,1) < 2000: robot.WER_SetMotor_K(-50,-50) while robot.get_channel_gray(1,1) >= 2000: robot.WER_SetMotor_K(-50,50) while robot.get_channel_gray(1,1) < 2000: robot.WER_SetMotor_K(-50,50) while robot.get_channel_gray(1,3) < 2000: robot.WER_SetMotor_K(-50,50) robot.WER_LineWay_C(60,15,0.3) while robot.get_channel_gray(1,1) < 2000: robot.WER_SetMotor_K(60,60) robot.sleep(0.2) robot.WER_SetMotor_T(-50,50,0.5) robot.WER_SetMotor_T(50,50,0.3) def r7(): while robot.get_channel_gray(1,1) < 2000: robot.WER_SetMotor_K(-40, -40) robot.WER_SetMotor_T(40,40,0.3) robot.WER_Around(40,-40,0) robot.WER_LineWay_C(50, 15,0.3) while robot.get_channel_gray(1,3) < 2000: robot.WER_SetMotor_K(40,40) robot.sleep(0.3) robot.WER_SetMotor_K(0,0) robot.WER_Around(-30,30,0) robot.WER_SetMotor_T(30,30,0.5) def r8(): robot.WER_SetMotor_T(-90,-60,4) def r9(): while robot.get_channel_gray(1, 1) < 2000: robot.WER_SetMotor_K(-30, -30) robot.WER_SetMotor_T(30, -30, 0.5) robot.WER_SetMotor_T(30, 28, 3) def r10(): while robot.get_channel_gray(1,5) < 2000: robot.WER_SetMotor_K(-30, -30) robot.WER_SetMotor_T(-30, 30, 0.3) robot.WER_SetMotor_T(30, 30, 3) # START main()#program entry","title":"My Code"},{"location":"robotics/WER2025/#challenges","text":"Doing this had a lot of challenges, from my first sessions building the robot, starting to program it, learning how to use C++ with the robot, etc. One of the biggest (unexpected) challenges was when they completely changed the syntax of the function calls 3 weeks before the competition! I had to spend a lot of time at home converting my 300 lines of code. Shortly after the competition, they changed from the old C202 robots to the new SK201 robots. This meant that I had to change all of my code from C++ to Python. However, the functions were very similar so it didn't take too long. The most challenging task model was task 4, because the dead battery was too low for a motor to reach, so I had to use a crank linkage with a claw on the end to move it. Also, you had to put the battery back in the low position so the claw had to be able to grab and release.","title":"Challenges"},{"location":"robotics/camjam/","text":"My First Robot 2022 - Aged 11 Details coming soon!","title":"CamJam Robot"},{"location":"robotics/camjam/#my-first-robot","text":"2022 - Aged 11","title":"My First Robot"},{"location":"robotics/camjam/#details-coming-soon","text":"","title":"Details coming soon!"},{"location":"robotics/picar/","text":"Picar S 2023-2025 - Aged 12-14 Details coming soon!","title":"Picar S"},{"location":"robotics/picar/#picar-s","text":"2023-2025 - Aged 12-14","title":"Picar S"},{"location":"robotics/picar/#details-coming-soon","text":"","title":"Details coming soon!"}]}