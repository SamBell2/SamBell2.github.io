{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sam Bell About Me I am a 14 year old electronics and programming enthusiast. I love computer science and everything related to digital making, and have since I learnt the basics of Python when I was 8. Since then, it has become my main hobby and the direction I want my career to go in. In 2020, I got my first Raspberry Pi and learnt about electronics. Recently I realised that digital making and robotics combine both of my main interests, and those are what I'm focussing on now. My Favourite Projects Project Description Link Chess Bot I created a fully-functional lookahead evaluation chess bot View Project CPU A simple 8-bit CPU that I am currently making View Project QR Code Generator I made a v5 QR code generator in python View Project WER 2025 An international robotics competition where I came 1st in the UK in my age category More information My Skills Technical Skills Programming : Python, Java, HTML/CSS Electronics : Soldering, PCB Design (KiCad) Tools : Git, Raspberry Pi, CAD (Autodesk Inventor & OpenSCAD) Soft Skills Problem Solving Communication Resilience Recent Achievements British champion in an international robotics competition Finalist in Cyber Switchup 2023 Predicted Grade 9 in GCSE Computer Science Get in Touch Email: samgbell2011@icloud.com Phone: 07468779147 Portfolio: https://sambell2.github.io View My Full Portfolio \u279c","title":"Welcome"},{"location":"#sam-bell","text":"","title":"Sam Bell"},{"location":"#about-me","text":"I am a 14 year old electronics and programming enthusiast. I love computer science and everything related to digital making, and have since I learnt the basics of Python when I was 8. Since then, it has become my main hobby and the direction I want my career to go in. In 2020, I got my first Raspberry Pi and learnt about electronics. Recently I realised that digital making and robotics combine both of my main interests, and those are what I'm focussing on now.","title":"About Me"},{"location":"#my-favourite-projects","text":"Project Description Link Chess Bot I created a fully-functional lookahead evaluation chess bot View Project CPU A simple 8-bit CPU that I am currently making View Project QR Code Generator I made a v5 QR code generator in python View Project WER 2025 An international robotics competition where I came 1st in the UK in my age category More information","title":"My Favourite Projects"},{"location":"#my-skills","text":"","title":"My Skills"},{"location":"#technical-skills","text":"Programming : Python, Java, HTML/CSS Electronics : Soldering, PCB Design (KiCad) Tools : Git, Raspberry Pi, CAD (Autodesk Inventor & OpenSCAD)","title":"Technical Skills"},{"location":"#soft-skills","text":"Problem Solving Communication Resilience","title":"Soft Skills"},{"location":"#recent-achievements","text":"British champion in an international robotics competition Finalist in Cyber Switchup 2023 Predicted Grade 9 in GCSE Computer Science","title":"Recent Achievements"},{"location":"#get-in-touch","text":"Email: samgbell2011@icloud.com Phone: 07468779147 Portfolio: https://sambell2.github.io","title":"Get in Touch"},{"location":"#view-my-full-portfolio","text":"","title":"View My Full Portfolio \u279c"},{"location":"gallery/","text":"My Projects My chess bot An 8-bit CPU An international robotics competition An illuminated button matrix My QR code generator A tiny laptop A text-based adventure game A magic mirror An app to solve sudoku A 4-wheeled robot My homemade safe. A wildlife camera An app to translate to and from morse code. My first robot","title":"Gallery"},{"location":"gallery/#my-projects","text":"My chess bot An 8-bit CPU An international robotics competition An illuminated button matrix My QR code generator A tiny laptop A text-based adventure game A magic mirror An app to solve sudoku A 4-wheeled robot My homemade safe. A wildlife camera An app to translate to and from morse code. My first robot","title":"My Projects"},{"location":"digital_making/laptop/","text":"Laptop","title":"Laptop"},{"location":"digital_making/laptop/#laptop","text":"","title":"Laptop"},{"location":"digital_making/light_fantastic/","text":"Light Fantastic","title":"Light Fantastic"},{"location":"digital_making/light_fantastic/#light-fantastic","text":"","title":"Light Fantastic"},{"location":"digital_making/magic_mirror/","text":"Magic Mirror","title":"Magic Mirror"},{"location":"digital_making/magic_mirror/#magic-mirror","text":"","title":"Magic Mirror"},{"location":"digital_making/wildlife_camera/","text":"Wildlife Camera","title":"Wildlife Camera"},{"location":"digital_making/wildlife_camera/#wildlife-camera","text":"","title":"Wildlife Camera"},{"location":"electronics/cpu/","text":"CPU An image of my CPU so far Overview This is my current project, it is an 8-bit CPU built out of individual ICs (Integrated Circuits). I got the idea in my Computer Science lessons at school, where I learnt how a CPU works and realised that it isn't actually as complex as I thought. I then started to make parts of it to test in Minecraft, before finding Ben Eater's similar project and using that as a guide to making the basic parts of the computer. Specs 6 - 48 Hz variable clock speed 1 core 64kB RAM 16 registers; r0 is a zero register 8-bit maths Von Neumann architecture My Aim I want to make an 8-bit CPU with 16 instructions. It will be fully Turing-complete. It will be able to do maths, store data, jump and branch to other parts of a program, and input and output to other devices. The instruction set I want to implement are adding, subtracting, NORing, right shifting, loading from RAM, storing to RAM, loading from a port, storing to a port, loading immediate values, adding immediate values, jumping around the program, branching to other parts of a program depending on a condition, and halting. How I'm Building It I am making it module by module, first breadboarding it to test it and make sure it works, then soldering it down to a solderable breadboard . So far, I have fully tested the clock module and have mostly soldered it down. I have also tested most of the ALU but had to stop because I ran out of wires! I am soldering the components to the top of the board so you can see them easily and the wires to the bottom of the board, just because I think it looks neater. The back of my CPU with all the wires Challenges I am learning a lot about the internal mechanisms of how computers actually work at the most detailed level, as well as soldering skills, PCB design, and electronic principles such as why pull-up/down resistors are actually necessary.","title":"CPU"},{"location":"electronics/cpu/#cpu","text":"An image of my CPU so far","title":"CPU"},{"location":"electronics/cpu/#overview","text":"This is my current project, it is an 8-bit CPU built out of individual ICs (Integrated Circuits). I got the idea in my Computer Science lessons at school, where I learnt how a CPU works and realised that it isn't actually as complex as I thought. I then started to make parts of it to test in Minecraft, before finding Ben Eater's similar project and using that as a guide to making the basic parts of the computer.","title":"Overview"},{"location":"electronics/cpu/#specs","text":"6 - 48 Hz variable clock speed 1 core 64kB RAM 16 registers; r0 is a zero register 8-bit maths Von Neumann architecture","title":"Specs"},{"location":"electronics/cpu/#my-aim","text":"I want to make an 8-bit CPU with 16 instructions. It will be fully Turing-complete. It will be able to do maths, store data, jump and branch to other parts of a program, and input and output to other devices. The instruction set I want to implement are adding, subtracting, NORing, right shifting, loading from RAM, storing to RAM, loading from a port, storing to a port, loading immediate values, adding immediate values, jumping around the program, branching to other parts of a program depending on a condition, and halting.","title":"My Aim"},{"location":"electronics/cpu/#how-im-building-it","text":"I am making it module by module, first breadboarding it to test it and make sure it works, then soldering it down to a solderable breadboard . So far, I have fully tested the clock module and have mostly soldered it down. I have also tested most of the ALU but had to stop because I ran out of wires! I am soldering the components to the top of the board so you can see them easily and the wires to the bottom of the board, just because I think it looks neater. The back of my CPU with all the wires","title":"How I'm Building It"},{"location":"electronics/cpu/#challenges","text":"I am learning a lot about the internal mechanisms of how computers actually work at the most detailed level, as well as soldering skills, PCB design, and electronic principles such as why pull-up/down resistors are actually necessary.","title":"Challenges"},{"location":"electronics/safe/","text":"Safe My finished safe Overview This is my first large electronics project: I made it when I was 9! It is a homemade safe with a 4-bit code to unlock the electromagnet. I sawed the MDF sheets and screwed them together, before adding an electromagnet inside and some metal washers on the door. On top are the electronics, which consist of a 4.5V battery pack, a DIP (Dual Inline Package) switch, 4 AND gates, 6 NOT gates, a transistor, a relay and a 12V battery. A schematic diagram of how the electronics work My Aim I wanted to make a safe with a door that locked, and you could only open it if you know the code. I mostly achieved that goal, as there is some resistance to the door when it is locked, but none when unlocked. However, it isn't a very safe safe as the electromagnet isn't very strong so you can just pull the door open, or you could just unplug the batteries. How it works There are 4 switches, each of which is on or off, The 1st, 3rd and 4th switches are inverted, The outputs of the inverters and the 2nd switch are ANDed together. This means that the output of this is only on if the 1st input is off, the 2nd input is on, and the 3rd and 4th inputs are off. The output of this switches a transistor to increase current, The output of the transistor switches a relay to increase voltage, The relay switches the electromagnet, The electromagnet pulls of washers glued to the inside of the door to close it Challenges It was my first large DIY project so I had to learn to use a saw and a drill safely, as well as the electronics. The main problem I had with the electronics was that I had forgotten pull-down resistors, so the inputs were floating (no definite value) when the switches were off. I eventually Googled the problem and put the resistors in and it worked, but I didn't realise why until I started making my CPU . What I would change If I built it again now, I would change a few things: I would use a solenoid pushing into a hole instead of an electromagnet. I would use a PCB to stop people unplugging wires. I would place all of the electronics inside the safe, with only the switches on top. I would use more switches, e.g. a 10-bit code","title":"Safe"},{"location":"electronics/safe/#safe","text":"My finished safe","title":"Safe"},{"location":"electronics/safe/#overview","text":"This is my first large electronics project: I made it when I was 9! It is a homemade safe with a 4-bit code to unlock the electromagnet. I sawed the MDF sheets and screwed them together, before adding an electromagnet inside and some metal washers on the door. On top are the electronics, which consist of a 4.5V battery pack, a DIP (Dual Inline Package) switch, 4 AND gates, 6 NOT gates, a transistor, a relay and a 12V battery. A schematic diagram of how the electronics work","title":"Overview"},{"location":"electronics/safe/#my-aim","text":"I wanted to make a safe with a door that locked, and you could only open it if you know the code. I mostly achieved that goal, as there is some resistance to the door when it is locked, but none when unlocked. However, it isn't a very safe safe as the electromagnet isn't very strong so you can just pull the door open, or you could just unplug the batteries.","title":"My Aim"},{"location":"electronics/safe/#how-it-works","text":"There are 4 switches, each of which is on or off, The 1st, 3rd and 4th switches are inverted, The outputs of the inverters and the 2nd switch are ANDed together. This means that the output of this is only on if the 1st input is off, the 2nd input is on, and the 3rd and 4th inputs are off. The output of this switches a transistor to increase current, The output of the transistor switches a relay to increase voltage, The relay switches the electromagnet, The electromagnet pulls of washers glued to the inside of the door to close it","title":"How it works"},{"location":"electronics/safe/#challenges","text":"It was my first large DIY project so I had to learn to use a saw and a drill safely, as well as the electronics. The main problem I had with the electronics was that I had forgotten pull-down resistors, so the inputs were floating (no definite value) when the switches were off. I eventually Googled the problem and put the resistors in and it worked, but I didn't realise why until I started making my CPU .","title":"Challenges"},{"location":"electronics/safe/#what-i-would-change","text":"If I built it again now, I would change a few things: I would use a solenoid pushing into a hole instead of an electromagnet. I would use a PCB to stop people unplugging wires. I would place all of the electronics inside the safe, with only the switches on top. I would use more switches, e.g. a 10-bit code","title":"What I would change"},{"location":"programming/chess_bot/","text":"Chess Bot A Lichess.org game where my bot won Overview I created a Java program that can play chess. It generates all legal moves and evaluates them, giving them points. It then plays the highest-ranking move. I have given it a UCI (Universal Chess Interface) frontend so it can interact with other chess apps. For example, I have given it a Lichess account ( SamFish96 ) and occasionally it is online.You can see the source code on GitHub . Inspiration I've been interested in complex decision making programs for a while, and a chess bot was a suitably complex but not overwhelming introduction to them. How it works It uses an 8x8 array of pieces or empty squares to represent the board. Whenever the chess app tells it that a move has been made, it simulates the move on its own board. When it needs to move one of its pieces, it looks at all of the possible moves that it can make, discards any that put it in check, then evaluates all of them. If it has time, it looks at the next turn or two as well. It then picks the move it thinks is best and plays it. Key Features Generates almost all possible moves. Uses syzygy tablebases for the endgame to ensure perfect moves. Detects checks, checkmates, stalemates and threefold repetition. Automatic detailed logging to see the bot's logic. Interacts with the Lichess bot API to play online. Improvements Add castling and en passant capabilities Increase speed Challenges I learnt a lot about Java, as before I had mainly programmed in Python. In particular, I use interfaces quite a bit. Looking for checks, checkmates, stalemates and other draws was far harder than I had anticipated, but I did eventually manage. Interacting with syzygy tables was a bit too complex for me to do (there are no Java libraries to read them) so I used an existing library called Fathom to do it.","title":"Chess Bot"},{"location":"programming/chess_bot/#chess-bot","text":"A Lichess.org game where my bot won","title":"Chess Bot"},{"location":"programming/chess_bot/#overview","text":"I created a Java program that can play chess. It generates all legal moves and evaluates them, giving them points. It then plays the highest-ranking move. I have given it a UCI (Universal Chess Interface) frontend so it can interact with other chess apps. For example, I have given it a Lichess account ( SamFish96 ) and occasionally it is online.You can see the source code on GitHub .","title":"Overview"},{"location":"programming/chess_bot/#inspiration","text":"I've been interested in complex decision making programs for a while, and a chess bot was a suitably complex but not overwhelming introduction to them.","title":"Inspiration"},{"location":"programming/chess_bot/#how-it-works","text":"It uses an 8x8 array of pieces or empty squares to represent the board. Whenever the chess app tells it that a move has been made, it simulates the move on its own board. When it needs to move one of its pieces, it looks at all of the possible moves that it can make, discards any that put it in check, then evaluates all of them. If it has time, it looks at the next turn or two as well. It then picks the move it thinks is best and plays it.","title":"How it works"},{"location":"programming/chess_bot/#key-features","text":"Generates almost all possible moves. Uses syzygy tablebases for the endgame to ensure perfect moves. Detects checks, checkmates, stalemates and threefold repetition. Automatic detailed logging to see the bot's logic. Interacts with the Lichess bot API to play online.","title":"Key Features"},{"location":"programming/chess_bot/#improvements","text":"Add castling and en passant capabilities Increase speed","title":"Improvements"},{"location":"programming/chess_bot/#challenges","text":"I learnt a lot about Java, as before I had mainly programmed in Python. In particular, I use interfaces quite a bit. Looking for checks, checkmates, stalemates and other draws was far harder than I had anticipated, but I did eventually manage. Interacting with syzygy tables was a bit too complex for me to do (there are no Java libraries to read them) so I used an existing library called Fathom to do it.","title":"Challenges"},{"location":"programming/morse_code/","text":"Morse Code Translator","title":"Morse Code Translator"},{"location":"programming/morse_code/#morse-code-translator","text":"","title":"Morse Code Translator"},{"location":"programming/qr_code_generator/","text":"QR Code Generator","title":"QR Code generator"},{"location":"programming/qr_code_generator/#qr-code-generator","text":"","title":"QR Code Generator"},{"location":"programming/scripted_journeys/","text":"Scripted Journeys","title":"Scripted Journeys"},{"location":"programming/scripted_journeys/#scripted-journeys","text":"","title":"Scripted Journeys"},{"location":"programming/sudoku_solver/","text":"Sudoku Solver","title":"Sudoku Solver"},{"location":"programming/sudoku_solver/#sudoku-solver","text":"","title":"Sudoku Solver"},{"location":"robotics/WER2025/","text":"World Educational Robotics 2025 Me testing my robot on one of the tasks Overview WER is an international robotics competition that takes place in Britain every July and the winners fo that competition qualify for the world championships in December in Shanghai. It is a large event, with over 6000 contestants in the championships. I joined in late December last year, and I went to the competition in England. I came 4th in my age category, but the top 3 all came from China to compete, so I qualified as the top British contestant and am going to the world championships! About the competition Each year, the competition has a different theme and map. This year was autonomous driving, and had pre-set tasks relating to the theme, e.g. Replacing the batteries in a model electric car and picking up containers to transport. You must compete in teams of 1 - 3. You get given a basic robot (plastic plate, 2 motors with wheels, 5 line sensors and a controller) and must build additional things to complete the required tasks. It uses Abilix robots which have a meccano-style construction. You must also program the robot using either a version of Scratch or Python to move around the map and complete the required tasks. Saturday Classes I go to a club every Saturday for an hour and a half. This is where I do most of my progress, testing, and learning. Here I get to use one of the club's robots. Before I went to the competition, about half of these sessions were learning things such as calibration curves and how to line up neatly with the tasks, and the other half were just preparing for the competition. Now I'm going to China, I need all the time I can get to train and prepare. I am being presented my award British Competition When I got to the competiton, I saw where the tasks were on the map and what the 2 new tasks were. I had 2 hours to get the robot to do all of the pre-set tasks in their locations and engineer solutions to the new tasks. Then we had a 3-minute judging session, lunch, and in the afternoon all of the tasks had been moved around. We had another 2 hours to prepare the robots and code for the new positions, then a 3 minute judging and the awards ceremony. Home programing As well as preparing my code at the Saturday classes, I also do some at home. The main bit that I did was a few months ago where I wrote all of the code to get to all of the positions and back in a single week, then on Saturday I tested it and most of it worked or almost worked first time! It only took me about 2 hours of debugging to get all of it working. I have also done other programming and preparing at home, sych as thinking of a few different methods for task 4. Ultimately, none of those methods are actually being used, as I saw some other really good designs at the competition which I have taken inspiration from. Challenges Doing this had a lot of challenges, from my first sessions building the robot, starting to program it, learning how to use C++ with the robot, etc. One of the biggest (unexpected) challenges was when they completely changed the syntax of the function calls 3 weeks before the competition! I had to spend a lot of time at home converting my 300 lines of code. Shortly after the competition, they changed from the old C202 robots to the new SK201 robots. This meant that I had to change all of my code from C++ to Python. However, the functions were very similar so it didn't take too long. The most challenging task model was task 4, because one of the batteries was too low for a motor to reach, so I had to use a crank linkage to move it. Also, you had to put a battery back in the low position so the claw had to be able to grab and release.","title":"WER 2025"},{"location":"robotics/WER2025/#world-educational-robotics-2025","text":"Me testing my robot on one of the tasks","title":"World Educational Robotics 2025"},{"location":"robotics/WER2025/#overview","text":"WER is an international robotics competition that takes place in Britain every July and the winners fo that competition qualify for the world championships in December in Shanghai. It is a large event, with over 6000 contestants in the championships. I joined in late December last year, and I went to the competition in England. I came 4th in my age category, but the top 3 all came from China to compete, so I qualified as the top British contestant and am going to the world championships!","title":"Overview"},{"location":"robotics/WER2025/#about-the-competition","text":"Each year, the competition has a different theme and map. This year was autonomous driving, and had pre-set tasks relating to the theme, e.g. Replacing the batteries in a model electric car and picking up containers to transport. You must compete in teams of 1 - 3. You get given a basic robot (plastic plate, 2 motors with wheels, 5 line sensors and a controller) and must build additional things to complete the required tasks. It uses Abilix robots which have a meccano-style construction. You must also program the robot using either a version of Scratch or Python to move around the map and complete the required tasks.","title":"About the competition"},{"location":"robotics/WER2025/#saturday-classes","text":"I go to a club every Saturday for an hour and a half. This is where I do most of my progress, testing, and learning. Here I get to use one of the club's robots. Before I went to the competition, about half of these sessions were learning things such as calibration curves and how to line up neatly with the tasks, and the other half were just preparing for the competition. Now I'm going to China, I need all the time I can get to train and prepare. I am being presented my award","title":"Saturday Classes"},{"location":"robotics/WER2025/#british-competition","text":"When I got to the competiton, I saw where the tasks were on the map and what the 2 new tasks were. I had 2 hours to get the robot to do all of the pre-set tasks in their locations and engineer solutions to the new tasks. Then we had a 3-minute judging session, lunch, and in the afternoon all of the tasks had been moved around. We had another 2 hours to prepare the robots and code for the new positions, then a 3 minute judging and the awards ceremony.","title":"British Competition"},{"location":"robotics/WER2025/#home-programing","text":"As well as preparing my code at the Saturday classes, I also do some at home. The main bit that I did was a few months ago where I wrote all of the code to get to all of the positions and back in a single week, then on Saturday I tested it and most of it worked or almost worked first time! It only took me about 2 hours of debugging to get all of it working. I have also done other programming and preparing at home, sych as thinking of a few different methods for task 4. Ultimately, none of those methods are actually being used, as I saw some other really good designs at the competition which I have taken inspiration from.","title":"Home programing"},{"location":"robotics/WER2025/#challenges","text":"Doing this had a lot of challenges, from my first sessions building the robot, starting to program it, learning how to use C++ with the robot, etc. One of the biggest (unexpected) challenges was when they completely changed the syntax of the function calls 3 weeks before the competition! I had to spend a lot of time at home converting my 300 lines of code. Shortly after the competition, they changed from the old C202 robots to the new SK201 robots. This meant that I had to change all of my code from C++ to Python. However, the functions were very similar so it didn't take too long. The most challenging task model was task 4, because one of the batteries was too low for a motor to reach, so I had to use a crank linkage to move it. Also, you had to put a battery back in the low position so the claw had to be able to grab and release.","title":"Challenges"},{"location":"robotics/camjam/","text":"My First Robot","title":"Camjam Robot"},{"location":"robotics/camjam/#my-first-robot","text":"","title":"My First Robot"},{"location":"robotics/picar/","text":"Picar S","title":"Picar S"},{"location":"robotics/picar/#picar-s","text":"","title":"Picar S"}]}