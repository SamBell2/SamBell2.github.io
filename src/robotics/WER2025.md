---
title: WER 2025
summary: An international robotics competition
year: 2025
tags:
    - Robotics
    - Electronics
    - Programming
    - Python
    - Engineering
    - C++
    - Logic
---
# World Educational Robotics 2025
*2025 - Aged 14*
![An image of my robot](images/WER2025.png)
*Me testing my robot on one of the tasks*
## Overview
[WER](http://wergame.org/){target="_blank" rel="noopener"} is an international educational robotics curriculum. There are many countries that host WER extra-curricular clubs with millions of participants, and some countries host robotics competitions. The most regular competitions take place in Britain every July and the winners from that competition qualify for the world championships in December in Shanghai. It is a large event, with over 6000 contestants in the championships (at least before Covid - there are fewer now). I joined in late December last year, and I went to the competition in England. I came 4th in my age category, but the top 3 all came from China to compete, so I qualified as the top British contestant and went to the world championships in Shanghai. The championships were on the 13th of December. It was a very stressful day, but in the end I got 3rd place!
## About the competition
Each year, the competition has a different theme and map. This year was autonomous driving, and had pre-set tasks relating to the theme, e.g. Replacing the batteries in a model electric car and picking up containers to transport. You must compete in teams of 1 - 3. You get given a basic robot (plastic plate, 2 motors with wheels, 5 line sensors and a controller) and must build additional things to complete the required tasks. It uses Abilix robots which have a meccano-style construction. You must also program the robot using either a version of Scratch or Python to move around the map and complete the required tasks.
## This Year's Setup
The map was 120cm x 220cm, and it had a start box, 10 different positions and a parking space. The different ways of getting points were as follows:  

* **Departure** *20pts*: Leave the start box at least once.
* **Task 1** *50pts*: Spin a bar around a certain number of times.
* **Task 2** *90pts*:  
    1. *10pts x 3*: Remove 3 different coloured plastic blocks from a stand.
    2. *10pts x 3*: Take all 3 blocks back to the start box.
    3. *30pts*: Keep the blocks in the same order as they were on the stand.
* **Task 3** *60pts*:
    1. *30pts*: Spin a bar around to drop a red block on the ground.
    2. *30pts*: Catch the red block and take it back to the start box.
* **Task 4** *160pts*: This is a model of an electric car. It has a model of a dead battery in the bottom and a model of a charged battery in the top.
    1. *30pts*: Remove the dead battery from the car.
    2. *30pts*: Remove the charged battery from the car.
    3. *30pts*: Take the dead battery back to the start box.
    4. *30pts*: Take the charged battery back to the start box.
    5. *40pts*: Put the charged battery back where the dead battery was.
* **Parking** *60pts*:
    1. *30pts*: End the run with at least 1 wheel in the parking space.
    2. *30pts*: Have the red block from **Task 3** in the parking space at the end of your run.
* **Bonus points** *Up to 40pts*: You get 40 bonus points. Each time you have to pick the robot up outside the start box, you lose 10 of these bonus points, until you have none left.
* **Field tasks** *100pts x 3*: There are 3 unseen tasks that first appear at the competition. Each one is worth 100pts.

Each of the tasks could be in any position. In case you're interested, the full rules are [here](WER2025rules.pdf){rel="noopener" target="_blank"} and this was the map:
![An image of the competition map](images/WER2025map.png)
## Saturday Classes
I go to a club every Saturday for an hour and a half. This is where I do most of my progress, testing, and learning. Here I get to use one of the club's robots. Before I went to the competition, about half of these sessions were learning things such as calibration curves and how to line up neatly with the tasks, and the other half were just preparing for the competition. Since the British competition, I have needed all the time I can get to train and practise, but now that the championships are over, I can relax again.
## British Competition
When I got to the competiton, I saw where the tasks were on the map and what the 2 new tasks were. I had 2 hours to get the robot to do all of the pre-set tasks in their locations and engineer solutions to the new tasks. Then we had a 3-minute judging session, lunch, and in the afternoon all of the tasks had been moved around. We had another 2 hours to prepare the robots and code for the new positions, then a 3 minute judging and the awards ceremony.
![Me getting presented my award](images/presentation.png)
*I am being presented my award*
## Home programing
As well as preparing my code at the Saturday classes, I also do some at home. The main bit that I did was a few months ago where I wrote all of the code to get to all of the positions and back in a single week, then on Saturday I tested it and most of it worked or almost worked first time! It only took me about 2 hours of debugging to get all of it working. I have also done other programming and preparing at home, sych as thinking of a few different methods for task 4. Ultimately, I didn't actually use any of those methods, as I saw some other really good designs at the competition which I have taken inspiration from.
## World Championship
Shortly after we arrived at the venue, we saw the 3 new tasks:  

* You had to lift a bar entirely off a stand and drop it on the floor.
* I can't remember what this one was, but it was between the other 2 in regards to difficulty
* You had to lift a small plastic box up and place it on a higher platform.

In the opening ceremony, I had to read out the competitors oath (essentially saying that we won't cheat) in English. However, while I was waiting to go up on the stage, most other teams started writing code, testing and debugging early, so I lost about 40 minutes of preparation time compared to the other teams. I then managed to test everything, but I realised that I had built my solution to task 4 the wrong way round! My code to go to the parking space also stopped working. In the end, I managed to get 350 points in the morning, which was the highest of the entire British division. In the afternoon, I managed to do a bit more. I solved the first of the additional tasks, and got the red block to the parking space (although neither of my wheels were actually in the box). I think I got 440 points. It was then the awards and closing ceremony. I came 3rd! I was aiming for top 50, so I was shocked when they read my name out!
## My Code
I have around 320 lines of Python code, organised into 5 sections. The first section is the main function. This is what I change the most often. After that, I have the code to complete each task once in position. Next, I have utility functions, such as calibrating the sensors and leaving the start box. Section 4 contains the functions to take me to each position. Many of these have small speed optimizations, such as skipping lines instead of going round the longer way. Finally, I have the code to take the robot back to the start box from each position. You can see the code here (it isn't the most efficient, but it works well enough):
<details>
<summary style="cursor: pointer">Show/Hide Code</summary>
```python
# IMPORTS
import robot

# MAIN
def main():
    start()
    park()


# UTILITY
def start():
    robot.WER_InitRobot(1,-1,2,1,1)
    robot.WER_SetMotor_T(30,30,1)
def setup():
    robot.WER_InitRobot(1,-1,2,1,1)
    robot.WER_Set_GrayscaleSensor()
def sideways():
    robot.WER_SetMotor_T(-30,-30,1)
    robot.WER_SetMotor_E(30,-30, 2, 2200)
    robot.WER_SetMotor_T(30,30,2)
    robot.WER_SetMotor_E(-30,30, 1, 2200)
    robot.WER_SetMotor_T(30,30,2.1)
    robot.WER_SetMotor_E(-30,30, 1, 2200)
    robot.WER_SetMotor_T(30,30,2.3)
def park():
    robot.WER_SetMotor_T(30, -30, 0.5)
    robot. WER_SetMotor_T(100, 100, 2.7)

# TASKS
def t1():
    robot.set_motor(3, -30)
    robot.sleep(1.2)
    robot.set_motor(3, 0)
def t2():
    robot.set_motor(3, 30)
    robot.sleep(1)
    robot.set_motor(3,10)
    robot.WER_SetMotor_T(-30, -30, 0.5)
    robot.set_motor(3, 0)
    robot.WER_SetMotor_T(-10, -10, 0.3)
def t3():
    robot.set_motor(3, 60)
    robot.sleep(1.5)
    robot.set_motor(3, 0)
def t4a():
    robot.set_motor(3, 10)
    while robot.get_encoder(3) < 1100:
        pass
    robot.set_motor(3,0)
    robot.set_motor(4,-30)
    robot.sleep(1)
    robot.set_motor(4,0)
def t4b():
    robot.set_motor(3,-10)
    while robot.get_encoder(3) > -1100:
        pass
    robot.set_motor(3,0)
def t5():
    robot.set_motor(3,20)
    robot.sleep(1)
    robot.set_motor(3,0)
def t6():
    pass
def t7():
    pass

# POSITIONS
def p1(task=None):
    robot.WER_LineWay_C(40,5,0.3)
    robot.WER_Around(30,-30,0)
    robot.WER_LineWay_C(40,15,0.3)
    robot.WER_Around(-30,30,0)
    robot.WER_LineWay_C(40,1,0.3)
    robot.WER_Around(-30, 30,0)
    robot.WER_LineWay_C(40,5,0.3)
    robot.WER_Around(30, -30, 0)
    robot.WER_AdvancedWay_T(30,3)
    if task != None:
        task()
        r1()
def p2(task=None):
    robot.WER_LineWay_C(60,5,0.2)
    robot.WER_Around(50,-50,0)
    robot.WER_LineWay_C(60,15,0.2)
    robot.WER_Around(-50,50,0)
    robot.WER_LineWay_C(60,1,0.3)
    robot.WER_AdvancedWay_T(30,1.2)
    if task != None:
        task()
        r2()
def p3(task=None):
    robot.WER_LineWay_C(60,5,0.3)
    robot.WER_Around(60, -60,0)
    for _ in range(8):
        robot.WER_AdvancedWay_T(60,0.1)
    while robot.get_channel_gray(1,5) < 2000:
        robot.WER_SetMotor_K(40,40)
    robot.sleep(0.4)
    robot.WER_SetMotor_K(0,0)
    robot.WER_Around(-60, 60,0)
    robot.WER_LineWay_C(60,1,0.1)
    robot.WER_Around(-60,60,1)
    while(robot.get_channel_gray(1, 5) < 2000):
        robot.WER_SetMotor_K(-60,-60)
    robot.sleep(0.3)
    robot.WER_SetMotor_K(0,0)
    while(robot.get_channel_gray(1, 5) < 2000):
        robot.WER_SetMotor_K(-60,-60)
    robot.WER_SetMotor_K(0,0)
    robot.WER_SetMotor_T(60, 60, 0.2)
    robot.WER_Around(60, -60, 0)
    robot.WER_AdvancedWay_T(30,2)
    if task != None:
        task()
        r3()
def p4(task=None):
    robot.WER_LineWay_C(40,5,0.3)
    robot.WER_Around(30,-30,0)
    robot.WER_LineWay_C(40,15,0.3)
    robot.WER_Around(-30,30,0)
    robot.WER_LineWay_C(40,1,0.3)
    while(robot.get_channel_gray(1, 5) < 1000):
        robot.WER_SetMotor_K(-35,35)
    robot.WER_SetMotor_K(0,0)
    while(robot.get_channel_gray(1, 3) < 1000):
        robot.WER_SetMotor_K(-35,35)
    robot.WER_SetMotor_K(0,0)
    while(robot.get_channel_gray(1, 5) < 1000):
        robot.WER_SetMotor_K(-35,-35)
    robot.sleep(0.3)
    robot.WER_SetMotor_K(0,0)
    while(robot.get_channel_gray(1, 5) < 1000):
        robot.WER_SetMotor_K(-35,-35)
    robot.sleep(0.3)
    robot.WER_SetMotor_K(0,0)
    while(robot.get_channel_gray(1, 5) < 1000):
        robot.WER_SetMotor_K(-35,-37)
    robot.WER_SetMotor_K(0,0)
    robot.WER_SetMotor_T(40, 40, 0.3)
    robot.WER_Around(30, -30, 0)
    robot.WER_AdvancedWay_T(30,1.7)
    if task != None:
        task()
        r4()
def p5(task=None):
    robot.WER_LineWay_C(40,5,0.3)
    robot.WER_Around(30,-30,0)
    robot.WER_LineWay_C(40,15,0.3)
    robot.WER_SetMotor_T(40, 40, 0.3)
    while(robot.get_channel_gray(1, 5) < 2000):
        robot.WER_SetMotor_K(60,60)
    robot.sleep(0.3)
    robot.WER_SetMotor_K(0,0)
    robot.WER_Around(-30, 30, 0)
    robot.WER_LineWay_C(40,5,0.3)
    robot.WER_Around(30,-30,0)
    robot.WER_AdvancedWay_T(30, 2.2)
    
    if task != None:
        task()
        r5()
def p6(task=None):
    robot.WER_LineWay_C(60,5,0.2)
    robot.WER_Around(30,-30,0)
    robot.WER_LineWay_C(60,15,0.2)
    robot.WER_Around(30, -30,0)
    robot.WER_LineWay_C(60,1,0.05)
    robot.WER_Around(-30, 30, 0)
    robot.WER_LineWay_C(60,5,0.2)
    robot.WER_SetMotor_T(30,30,0.2)
    robot.WER_LineWay_C(60,5,0.3)
    robot.WER_SetMotor_T(30,30,2.2)
    if task != None:
        task()
        r6()
def p7(task=None):
    robot.WER_LineWay_C(40,5,0.3)
    robot.WER_Around(30,-30,0)
    robot.WER_LineWay_C(40,15,0.3)
    robot.WER_SetMotor_T(40, 40, 0.3)
    while(robot.get_channel_gray(1, 5) < 2000):
        robot.WER_SetMotor_K(60,60)
    robot.sleep(0.3)
    robot.WER_SetMotor_K(0,0)
    while robot.get_channel_gray(1,3) < 3000:
        robot.WER_SetMotor_K(40,-40)
    robot.WER_AdvancedWay_T(40,1.8)
    if task != None:
        task()
        r7()
def p8(task=None):
    robot.WER_LineWay_C(60,5,0.2)
    robot.WER_Around(50,-50,0)
    robot.WER_LineWay_C(60,15,0.2)
    x = robot.get_encoder(1)
    print(x)
    while robot.get_encoder(1) > x-5200:
        robot.WER_SetMotor_K(60,60)
        print(robot.get_encoder(1))
    robot.WER_SetMotor_K(0,0)
    robot.WER_Around(60,0,0)
    robot.WER_Around(60,0,0)
    robot.WER_AdvancedWay_T(30, 1.2)
    
    if task != None:
        task()
        r8()
def p9(task=None):
    robot.WER_LineWay_C(40,5,0.3)
    robot.WER_Around(30,-30,0)
    robot.WER_LineWay_C(40,15,0.3)
    robot.WER_Around(30, -30,0)
    robot.WER_LineWay_C(30,1,0.3)
    robot.WER_AdvancedWay_T(20, 1.8)
    if task != None:
        task()
        r9()
def p10(task=None):
    robot.WER_LineWay_C(40,5,0.3)
    robot.WER_Around(30,-30,0)
    robot.WER_LineWay_C(40,15,0.3)
    robot.WER_Around(-30,30,0)
    robot.WER_LineWay_C(40,1,0.3)
    robot.WER_Around(-30, 30, 0)
    robot.WER_LineWay_C(40, 5, 0.3)
    robot.WER_AdvancedWay_T(30,1.2)
    if task != None:
        task()
        r10()

# RETURNS
def r1():
    robot.WER_SetMotor_T(-50, -60, 2.2)
def r2():
    while(robot.get_channel_gray(1, 1) < 2000):
        robot.WER_SetMotor_K(-60,-60)
    robot.sleep(0.2)
    while(robot.get_channel_gray(1, 1) < 2000):
        robot.WER_SetMotor_K(-60,-60)
    robot.WER_SetMotor_K(60, 60)
    robot.sleep(0.2)
    robot.WER_SetMotor_K(0,0)
    robot.WER_Around(-60, 60, 0)
    robot.WER_LineWay_C(60, 1, 0.2)
    robot.WER_Around(-60, 60, 0)
    robot.WER_LineWay_C(60, 15, 0.3)
def r3():
    while robot.get_channel_gray(1, 5) < 2000:
        robot.WER_SetMotor_K(-60, -60)
    robot.WER_SetMotor_T(-60, -60, 0.3)
    while robot.get_channel_gray(1, 5) < 2000:
        robot.WER_SetMotor_K(-60, -60)
    robot.WER_SetMotor_T(60,60,0.3)
    robot.WER_Around(-60, 60, 0)
    robot.WER_LineWay_C(60,15,0)
    robot.WER_SetMotor_T(60, 60, 0.3)
    while robot.get_channel_gray(1, 1) < 2000:
        robot.WER_SetMotor_K(60, 60)
    robot.WER_SetMotor_K(0,0)
    robot.WER_SetMotor_T(-60, 60, 0.4)
    robot.WER_SetMotor_T(60, 60, 0.3)
def r4():
    while robot.get_channel_gray(1, 1) < 2000:
        robot.WER_SetMotor_K(-30, -30)
    robot.WER_SetMotor_T(-30, -30, 0.3)
    while robot.get_channel_gray(1, 5) < 2000:
        robot.WER_SetMotor_K(-30, -30)
    robot.WER_SetMotor_T(30,30,0.3)
    robot.WER_Around(-30, 30, 0)
    robot.WER_LineWay_C(40,15,0)
    robot.WER_SetMotor_T(30, 30, 0.3)
    while robot.get_channel_gray(1, 1) < 2000:
        robot.WER_SetMotor_K(30, 30)
    robot.WER_SetMotor_K(0,0)
    robot.WER_SetMotor_T(-30, 30, 0.5)
    robot.WER_SetMotor_T(30, 30, 0.3)
def r5():
    robot.WER_SetMotor_T(-54,-50,5.5)
def r6():
    while robot.get_channel_gray(1,1) < 2000:
        robot.WER_SetMotor_K(-50,-50)
    while robot.get_channel_gray(1,1) >= 2000:
        robot.WER_SetMotor_K(-50,50)
    while robot.get_channel_gray(1,1) < 2000:
        robot.WER_SetMotor_K(-50,50)
    while robot.get_channel_gray(1,3) < 2000:
        robot.WER_SetMotor_K(-50,50)
    robot.WER_LineWay_C(60,15,0.3)
    while robot.get_channel_gray(1,1) < 2000:
        robot.WER_SetMotor_K(60,60)
    robot.sleep(0.2)
    robot.WER_SetMotor_T(-50,50,0.5)
    robot.WER_SetMotor_T(50,50,0.3)
def r7():
    while robot.get_channel_gray(1,1) < 2000:
        robot.WER_SetMotor_K(-40, -40)
    robot.WER_SetMotor_T(40,40,0.3)
    robot.WER_Around(40,-40,0)
    robot.WER_LineWay_C(50, 15,0.3)
    while robot.get_channel_gray(1,3) < 2000:
        robot.WER_SetMotor_K(40,40)
    robot.sleep(0.3)
    robot.WER_SetMotor_K(0,0)
    robot.WER_Around(-30,30,0)
    robot.WER_SetMotor_T(30,30,0.5)
def r8():
    robot.WER_SetMotor_T(-90,-60,4)
def r9():
    while robot.get_channel_gray(1, 1) < 2000:
        robot.WER_SetMotor_K(-30, -30)
    robot.WER_SetMotor_T(30, -30, 0.5)
    robot.WER_SetMotor_T(30, 28, 3)
def r10():
    while robot.get_channel_gray(1,5) < 2000:
        robot.WER_SetMotor_K(-30, -30)
    robot.WER_SetMotor_T(-30, 30, 0.3)
    robot.WER_SetMotor_T(30, 30, 3)

# START
main()#program entry
```
</details>
## Challenges
Doing this had a lot of challenges, from my first sessions building the robot, starting to program it, learning how to use C++ with the robot, etc. One of the biggest (unexpected) challenges was when they completely changed the syntax of the function calls *3 weeks* before the competition! I had to spend a lot of time at home converting my 300 lines of code. Shortly after the competition, they changed from the old C202 robots to the new SK201 robots. This meant that I had to change all of my code from C++ to Python. However, the functions were very similar so it didn't take too long. The most challenging task model was task 4, because the dead battery was too low for a motor to reach, so I had to use a crank linkage with a claw on the end to move it. Also, you had to put the battery back in the low position so the claw had to be able to grab and release.